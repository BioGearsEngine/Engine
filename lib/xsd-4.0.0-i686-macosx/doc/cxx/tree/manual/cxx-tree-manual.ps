%!PS
%%Title: C++/Tree Mapping User Manual
%%Creator: html2ps version 1.0 beta7
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 471 F div D
/IL 621 F div D
/PS 791 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [12 10 19 17 15 13 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}{ h }][{ h }{()}][{()}{()}]] D
/ZZ [[{ (July 2014) }{ Pn }][{ Pn }{ (July 2014) }][{ Ti(, v)join ME 0 get join }{ Ti(, v)join ME 0 get join }]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Tp t D
/Fe f D
/TI 2 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 706 D
/yR 706 D
/Wl 471 F div D
/Wr 471 F div D
/hL 621 F div D
/hR 621 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.6 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th { (
) 2 Al()BR (
  ) 0 1 -1 H()4 FZ (C++/Tree Mapping User Manual) ES()EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
) Ea()BR (
  ) 0 P (Revision ) ME 0 get join(     July 2014)join EP (
  ) 0 P (Copyright © 2005-2014 CODE SYNTHESIS TOOLS CC) EP (

  ) 0 P (Permission is granted to copy, distribute and/or modify this
     document under the terms of the
     ) R0 2 A (GNU Free
     Documentation License, version 1.2) EA (; with no Invariant Sections,
     no Front-Cover Texts and no Back-Cover Texts.
  ) EP (

  ) 0 P (This document is available in the following formats:
     ) R1 2 A (XHTML) EA (,
     ) R2 2 A (PDF) EA (, and
     ) R3 2 A (PostScript) EA (.) EP()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{/Ms t D NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()0 Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\234)(\233)(\253\240)(\232)(\273)(\253)][(')(`)(\253\240)(\231)(\273)(\253)]] D
/QC [[(\234)(\234)(\240\273)(\233)(\253)(\273)][(')(')(\240\273)(`)(\253)(\273)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 1 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta7) /Author () /Keywords (xsd, xml, schema, c++, mapping, data, binding, tree, serialization, guide, manual, examples) /Subject ()
 /Title (C++/Tree Mapping User Manual) /DOCINFO pdfmark
/ND 1 D
/HN [(1) (1) (1) (1) (1) (1) (1) (2) (2) (2) (2) (3) (3) (4) (4) (5) (5) (5)
(6) (6) (7) (7) (??) (10) (11) (12) (13) (14) (16) (19) (20) (21) (22) (24)
(24) (25) (26) (27) (28) (29) (29) (30) (31) (32) (33) (37) (37) (37) (39)
(41) (45) (48) (55) (55) (58) (59) (60) (62) (64) (65) (68) (74) (75) (80)
(82) (85) (85) (86) (88) (89) (89) (90) (91) (91) (91) (92) (92) (93) (93)
(94) (94) (94) (96) (97) (99) (99) (100) (100) (100) (101) (101) (102) (103)
(103) (106) (107) (??) (1) (1) (1) (1) (2) (2) (2) (2) (3) (3) (4) (4) (5)
(5) (5) (6) (6) (7) (7) (10) (11) (12) (13) (14) (16) (19) (20) (21) (22)
(24) (24) (25) (26) (27) (28) (29) (29) (30) (31) (32) (33) (37) (37) (37)
(39) (41) (45) (48) (55) (55) (58) (59) (60) (62) (64) (65) (68) (74) (75)
(80) (82) (85) (85) (86) (88) (89) (89) (90) (91) (91) (91) (92) (92) (93)
(93) (94) (94) (94) (96) (97) (99) (99) (100) (100) (100) (101) (101) (102)
(103) (103) (106) (107)] D
/h0 [()(Table of Contents)] D
/h1 [(1\240\240)(Preface)] D
/h2 [(1.1\240\240)(About This Document)] D
/h3 [(1.2\240\240)(More Information)] D
/h4 [(2\240\240)(1 Introduction)] D
/h5 [(3\240\240)(2 C++/Tree Mapping)] D
/h6 [(3.1\240\240)(2.1 Preliminary Information)] D
/h7 [(3.1.1\240\240)(2.1.1 C++ Standard)] D
/h8 [(3.1.2\240\240)(2.1.2 Identifiers)] D
/h9 [(3.1.3\240\240)(2.1.3 Character Type and Encoding)] D
/h10 [(3.1.4\240\240)(2.1.4 XML Schema Namespace)] D
/h11 [(3.1.5\240\240)(2.1.5 Anonymous Types)] D
/h12 [(3.2\240\240)(2.2 Error Handling)] D
/h13 [(3.2.1\240\240)(2.2.1 xml_schema::duplicate_id)] D
/h14 [(3.3\240\240)(2.3 Mapping for import and include)] D
/h15 [(3.3.1\240\240)(2.3.1 Import)] D
/h16 [(3.3.2\240\240)(2.3.2 Inclusion with Target Namespace)] D
/h17 [(3.3.3\240\240)(2.3.3 Inclusion without Target Namespace)] D
/h18 [(3.4\240\240)(2.4 Mapping for Namespaces)] D
/h19 [(3.5\240\240)(2.5 Mapping for Built-in Data Types)] D
/h20 [(3.5.1\240\240)(2.5.1 Inheritance from Built-in Data Types)] D
/h21 [(3.5.2\240\240)(2.5.2 Mapping for anyType)] D
/h22 [(3.5.3\240\240)(2.5.3 Mapping for anySimpleType)] D
/h23 [(3.5.4\240\240)(2.5.4 Mapping for QName)] D
/h24 [(3.5.5\240\240)(2.5.5 Mapping for IDREF)] D
/h25 [(3.5.6\240\240)(2.5.6 Mapping for base64Binary and hexBinary)] D
/h26 [(3.6\240\240)(2.5.7 Time Zone Representation)] D
/h27 [(3.7\240\240)(2.5.8 Mapping for date)] D
/h28 [(3.8\240\240)(2.5.9 Mapping for dateTime)] D
/h29 [(3.9\240\240)(2.5.10 Mapping for duration)] D
/h30 [(3.10\240\240)(2.5.11 Mapping for gDay)] D
/h31 [(3.11\240\240)(2.5.12 Mapping for gMonth)] D
/h32 [(3.12\240\240)(2.5.13 Mapping for gMonthDay)] D
/h33 [(3.13\240\240)(2.5.14 Mapping for gYear)] D
/h34 [(3.14\240\240)(2.5.15 Mapping for gYearMonth)] D
/h35 [(3.15\240\240)(2.5.16 Mapping for time)] D
/h36 [(3.16\240\240)(2.6 Mapping for Simple Types)] D
/h37 [(3.16.1\240\240)(2.6.1 Mapping for Derivation by Restriction)] D
/h38 [(3.16.2\240\240)(2.6.2 Mapping for Enumerations)] D
/h39 [(3.16.3\240\240)(2.6.3 Mapping for Derivation by List)] D
/h40 [(3.16.4\240\240)(2.6.4 Mapping for Derivation by Union)] D
/h41 [(3.17\240\240)(2.7 Mapping for Complex Types)] D
/h42 [(3.17.1\240\240)(2.7.1 Mapping for Derivation by Extension)] D
/h43 [(3.17.2\240\240)(2.7.2 Mapping for Derivation by Restriction)] D
/h44 [(3.18\240\240)(2.8 Mapping for Local Elements and Attributes)] D
/h45 [(3.18.1\240\240)(2.8.1 Mapping for Members with the One Cardinality Class)] D
/h46 [(3.18.2\240\240)(2.8.2 Mapping for Members with the Optional Cardinality Class)] D
/h47 [(3.18.3\240\240)(2.8.3 Mapping for Members with the Sequence Cardinality Class)] D
/h48 [(3.18.4\240\240)(2.8.4 Element Order)] D
/h49 [(3.19\240\240)(2.9 Mapping for Global Elements)] D
/h50 [(3.19.1\240\240)(2.9.1 Element Types)] D
/h51 [(3.19.2\240\240)(2.9.2 Element Map)] D
/h52 [(3.20\240\240)(2.10 Mapping for Global Attributes)] D
/h53 [(3.21\240\240)(2.11 Mapping for xsi:type and Substitution Groups)] D
/h54 [(3.22\240\240)(2.12 Mapping for any and anyAttribute)] D
/h55 [(3.22.1\240\240)(2.12.1 Mapping for any with the One Cardinality Class)] D
/h56 [(3.22.2\240\240)(2.12.2 Mapping for any with the Optional Cardinality Class)] D
/h57 [(3.22.3\240\240)(2.12.3 Mapping for any with the Sequence Cardinality Class)] D
/h58 [(3.22.4\240\240)(2.12.4 Element Wildcard Order)] D
/h59 [(3.22.5\240\240)(2.12.5 Mapping for anyAttribute)] D
/h60 [(3.23\240\240)(2.13 Mapping for Mixed Content Models)] D
/h61 [(4\240\240)(3 Parsing)] D
/h62 [(4.1\240\240)(3.1 Initializing the Xerces-C++ Runtime)] D
/h63 [(4.2\240\240)(3.2 Flags and Properties)] D
/h64 [(4.3\240\240)(3.3 Error Handling)] D
/h65 [(4.3.1\240\240)(3.3.1 xml_schema::parsing)] D
/h66 [(4.3.2\240\240)(3.3.2 xml_schema::expected_element)] D
/h67 [(4.3.3\240\240)(3.3.3 xml_schema::unexpected_element)] D
/h68 [(4.3.4\240\240)(3.3.4 xml_schema::expected_attribute)] D
/h69 [(4.3.5\240\240)(3.3.5 xml_schema::unexpected_enumerator)] D
/h70 [(4.3.6\240\240)(3.3.6 xml_schema::expected_text_content)] D
/h71 [(4.3.7\240\240)(3.3.7 xml_schema::no_type_info)] D
/h72 [(4.3.8\240\240)(3.3.8 xml_schema::not_derived)] D
/h73 [(4.3.9\240\240)(3.3.9 xml_schema::no_prefix_mapping)] D
/h74 [(4.4\240\240)(3.4 Reading from a Local File or URI)] D
/h75 [(4.5\240\240)(3.5 Reading from std::istream)] D
/h76 [(4.6\240\240)(3.6 Reading from xercesc::InputSource)] D
/h77 [(4.7\240\240)(3.7 Reading from DOM)] D
/h78 [(5\240\240)(4 Serialization)] D
/h79 [(5.1\240\240)(4.1 Initializing the Xerces-C++ Runtime)] D
/h80 [(5.2\240\240)(4.2 Namespace Infomap and Character Encoding)] D
/h81 [(5.3\240\240)(4.3 Flags)] D
/h82 [(5.4\240\240)(4.4 Error Handling)] D
/h83 [(5.4.1\240\240)(4.4.1 xml_schema::serialization)] D
/h84 [(5.4.2\240\240)(4.4.2 xml_schema::unexpected_element)] D
/h85 [(5.4.3\240\240)(4.4.3 xml_schema::no_type_info)] D
/h86 [(5.5\240\240)(4.5 Serializing to std::ostream)] D
/h87 [(5.6\240\240)(4.6 Serializing to xercesc::XMLFormatTarget)] D
/h88 [(5.7\240\240)(4.7 Serializing to DOM)] D
/h89 [(6\240\240)(5 Additional Functionality)] D
/h90 [(6.1\240\240)(5.1 DOM Association)] D
/h91 [(6.2\240\240)(5.2 Binary Serialization)] D
/h92 [(7\240\240)(Appendix A \236 Default and Fixed Values)] D
/Hr [97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114
115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150
151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168
169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186
187 188]D
/HV [1 2 2 1 1 2 3 3 3 3 3 2 3 2 3 3 3 2 2 3 3 3 3 3 3 2 2 2 2 2 2 2 2
2 2 2 3 3 3 3 2 3 3 2 3 3 3 3 2 3 3 2 2 2 3 3 3 3 3 2 1 2 2 2 3 3 3 3 3
3 3 3 3 2 2 2 2 1 2 2 2 2 3 3 3 2 2 2 1 2 2 1]D
/Cn [2 0 0 0 23 5 0 0 0 0 0 1 0 3 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 4 0 0 0 0 2 0 0 4 0 0 0 0 2 0 0 0 0 5 0 0 0 0 0 0 7 0 0 9 0 0 0 0 0
0 0 0 0 0 0 0 0 7 0 0 0 3 0 0 0 0 0 0 2 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R0 (http://www.codesynthesis.com/licenses/fdl-1.2.txt) D
/R1 (http://www.codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/index.xhtml) D
/R2 (http://www.codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/cxx-tree-manual.pdf) D
/R3 (http://www.codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/cxx-tree-manual.ps) D
/R1 (http://www.codesynthesis.com/products/xsd) D
/R2 (http://codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/index.xhtml) D
/R3 (http://codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/cxx-tree-manual.pdf) D
/R4 (http://codesynthesis.com/projects/xsd/documentation/cxx/tree/manual/cxx-tree-manual.ps) D
/R5 (http://www.codesynthesis.com/projects/xsd/documentation/cxx/tree/guide/) D
/R6 (http://wiki.codesynthesis.com/Tree/Customization_guide) D
/R7 (http://wiki.codesynthesis.com/Tree/FAQ) D
/R8 (http://www.codesynthesis.com/projects/xsd/documentation/xsd.xhtml) D
/R9 (http://www.codesynthesis.com/mailman/listinfo/xsd-users) D
/R10 (http://www.codesynthesis.com/pipermail/xsd-users/) D
/R11 (http://en.wikipedia.org/wiki/Character_code) D
/TS {
 tables E get /table E D
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D pop pop
 /w W D /eps 0.1 D /OU f D /PL 1 D
 /FN EF 21 get D EZ 21 get Ey 21 get FS
 0 1 1{
  /pass E D
  0 1 nrow{
   /irow E D
   /cells rdesc irow get 6 get D
   0 1 ncol{
    /icol E D
    /cell cells icol get D
    cell 0 ne{
     cell aload pop /ang E D /CB E D pop pop pop
     /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
     /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
     /cmin E D /proc E D
     rspan 0 eq{/rspan nrow irow sub 1 add D}if
     cspan 0 eq{/cspan ncol icol sub 1 add D}if
     pass 0 eq cspan 1 eq and pass 1 eq cspan 1 gt and or{
      /W 1e5 D /LL W D /PH 1 D
      ctype 1 eq{() BD}if
      RC align NA
      AT 4 eq{/CD t D /DC dp D /LN 0 D /M1 0 D /M2 0 D}{/CD f D}ie
      0 0 M /LM 0 D proc exec BN
      AT 4 eq{
       LN array astore cell 15 3 -1 roll put
       cdesc icol get dup dup 5 get M1 lt{5 M1 put}{5 get /M1 E D}ie
       dup 6 get M2 lt{6 M2 put}{6 get /M2 E D}ie
       /LM M1 M2 add D
      }if
      /CD f D
      ang 0 ne{/LM CP E pop neg D}if
      /thiswid LM left add right add eps add D
      /oldmin 0 D /oldmax 0 D
      0 1 cspan 1 sub{
       icol add cdesc E get dup 2 get /oldmax E oldmax add D
       1 get /oldmin E oldmin add D
      }for
      thiswid oldmax ge{
       0 1 cspan 1 sub{
        icol add cdesc E get dup 2 E 2 get oldmax 0 eq
         {pop thiswid cspan div}{thiswid mul oldmax div}ie
        put
       }for
      }if
      nowrap 1 eq{
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }{
       /W 0 D /LL W D /PH 2 D
       ctype 1 eq{() ES () BD}if
       0 0 M /LM 0 D RC proc exec BN
       /thiswid LM left add right add eps add D
       thiswid oldmin ge{
        0 1 cspan 1 sub{
         icol add cdesc E get dup 1 E 1 get oldmin 0 eq
          {pop thiswid cspan div}{thiswid mul oldmin div}ie
         put
        }for
       }if
      }ie
      ctype 1 eq{() ES}if
     }if
    }if
   }for
  }for
 }for
 /tmin 0 D /tmax 0 D
 0 1 ncol{
  cdesc E get dup 1 get E 2 get 2 copy gt{pop dup}if
  tmax add /tmax E D tmin add /tmin E D
 }for
 twid 0 lt{twid neg IW gt{IW neg}{twid}ie /twid E D}if
 tdesc 0 twid neg tmin 2 copy lt{E}if pop put
 tdesc 1 twid neg tmax 2 copy lt{E}if pop put
 /W w D /LL W D /OU t D /PH 0 D /PL 0 D
} D
/PT {
 /PL PL 1 add D
 tables E get /table E D Tm 21 get Ts mul BE
 PL 2 ge{save}if
 /SL SL 1 add D /FN EF 21 get D EZ 21 get Ey 21 get FS
 table aload pop /rdesc E D /cdesc E D /tdesc E D
 tdesc aload pop /capalg E D /caption E D /rules E D /frame E D /nfoot E D
  /nhead E D /ncol E D /nrow E D /border E D /twid E D /units E D /talign E D
  /flow E D /clear E D /tclass E D /tmax E D /tmin E D
 /w W D /xo XO D /mr MR D /ll LL D /lg LG D /ai AI D /bc BC D /nr NR D /ar AR D
 /tr TR D /ui UI D /ph PH D /a0 A0 D /pf PF D /at AT D /av AV D /al AL D
 /Le LE D /la La D
 talign 0 lt{/talign AL 0 gt{AV AL get}{A0 2 le{A0}{0}ie}ie D}if
 ph 1 eq ph 2 eq or{
  NL ph 1 eq{tmax}{tmin}ie dup XO add LM gt{/LM E XO add D}{pop}ie LM E
 }{
  /PH 3 D /LE 1e5 D RC %ZF
  border 0 gt{/border 1 D}if
  /twidth 0 D /avail W xo sub D
  twid 0 eq{0 1 ncol{cdesc E get dup 2 get E 3 get dup 0 gt{div neg dup twid lt
   {/twid E D}{pop}ie}{pop pop}ie}for}if
  /twid twid dup 0 lt{neg avail 2 copy gt{E}if pop}{avail mul}ie D
  /OK t D 0 1 ncol{cdesc E get dup 1 get E 3 get twid mul gt{/OK f D}if}for
  0 1 ncol{
   cdesc E get dup 1 get /colmin E D dup 3 get /cwid E twid mul D dup
   tmax avail le{2 get}if
   tmin avail le tmax avail gt and{
    dup 2 get E 1 get dup 3 1 roll sub avail tmin sub mul tmax tmin sub div add
   }if
   tmin avail gt{1 get}if
   0 E colmin cwid lt OK and{pop cwid}if dup /twidth E twidth add D put
  }for
  /OU f D CP
  tmin twid le{
   0 1 ncol{cdesc E get dup 0 get twidth div twid mul 0 E put}for
   /twidth twid D
  }if
  CP printcap CP E pop sub /caphig E D pop
  0 1 1{
   /pass E D
   0 1 nrow{
    /irow E D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      cell aload pop /ang E D /CB E D pop pop pop
      /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
      /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
      /cmin E D /proc E D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /W 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /W E W add D}for
      pass 0 eq rspan 1 eq and pass 1 eq rspan 1 gt and or{
       ctype 1 eq{() BD}if
       /W W left sub right sub D /XO 0 D /EO 0 D SI
       /A0 align D RC align NA
       AT 4 eq{
        /DC dp D /DO 0 D /ID 1 D
        0 1 DV length 1 sub{DV E get dup DO gt{/DO E D}{pop}ie}for
        /Lo DO DV 0 get sub D /L1 Lo D
       }if
       0 0 M /BP t D /Fl t D /MF 0 D /FB 0 D
       proc exec T not{/CI 0 D}if BN 0 FB neg R MF 0 eq{/MF CS D}if
       CP /thishig E neg bot add top add CI add D pop
       ang 0 ne{/thishig LM bot add top add D}if
       cell 16 MF put cell 17 Ya put cell 18 thishig put
       valign 4 eq{
        /below thishig Ya sub D
        rdesc irow get dup dup 4 get Ya lt
         {4 Ya put}{4 get /Ya E D}ie
        dup 5 get below lt{5 below put}{5 get /below E D}ie
        /thishig Ya below add D
       }if
       ctype 1 eq{()ES}if
       /oldhig 0 D
       0 1 rspan 1 sub{
        irow add rdesc E get 0 get /oldhig E oldhig add D
       }for
       thishig oldhig ge{
        0 1 rspan 1 sub{
         irow add rdesc E get dup 0 E 0 get oldhig 0 eq
          {pop thishig rspan div}{thishig mul oldhig div}ie
         put
        }for
       }if
      }if
     }if
    }for
   }for
  }for M RC %ZF
  /thight 0 D /racc 0 D /maxh 0 D /brk 0 D /rbeg nhead nfoot add D
  0 1 nrow{
   rdesc E get dup 0 get dup /thight E thight add D
   brk 0 eq{/racc E D}{/racc E racc add D}ie
   racc maxh gt{/maxh racc D}if 2 get /brk E D
  }for
  ph 3 ge{thight caphig add E}if
  ph 0 eq ph 4 eq or{
   /PH 4 D /LE Le D /OU Ou D /yoff 0 D /headsz 0 D
   0 1 nhead 1 sub{rdesc E get 0 get headsz add /headsz E D}for
   /footsz 0 D
   0 1 nfoot 1 sub{rdesc E nhead add get 0 get footsz add /footsz E D}for
   /ahig LE BO add MI add D /maxh maxh headsz add footsz add D
   /thight thight headsz add footsz add D
   tmin avail gt maxh ahig gt or
    {/Sf avail tmin div dup ahig maxh div gt{pop ahig maxh div}if D /SA t D}
    {/Sf 1 D}ie
   tclass 1 eq thight LE 15 sub gt and
    {/SA t D LE 15 sub thight div dup Sf lt{/Sf E D}{pop}ie}if
   SA{Sf Sf scale /ll ll Sf div D /xo xo Sf div D /LE LE Sf div D
    /mr mr Sf div D /BO BO Sf div D /ahig ahig Sf div D}if
   nhead nfoot add getwid
   LE CP E pop add capalg 0 eq{caphig sub}if
   bT{f}{dup thight lt thight ahig lt and}ie
   E headsz sub footsz sub rwid lt or{NP}if
   capalg 0 eq{printcap -8 SP}if
   CP /ycur E D pop
   printhead
   rbeg 1 nrow{/row E D row
    getwid
    ycur yoff add rwid sub footsz sub LE add 0 lt
    {nfoot 0 gt{printfoot}if Tf NP /rbeg irow1 D
     Ba{MI /MI MI SA{Sf div}if D MI SP /MI E D}if
     CP /ycur E D pop /yoff 0 D printhead}if
    irow1 printrow
   }for
   printfoot /row row 1 add D Tf
   0 ycur yoff add M
   capalg 1 eq{/EO 0 D SI -3 SP printcap}if
   Sf 1 lt{1 Sf div dup scale /ll ll Sf mul D /xo xo Sf mul D /LE LE Sf mul D
    /mr mr Sf mul D /BO BO Sf mul D /SA f D}if
   /EO 0 D
  }if
 }ie
 /W w D /XO xo D /MR mr D /LL ll D /LG lg D /AI ai D /BC bc D /NR nr D /AR ar D
 /TR tr D /UI ui D /PH ph D /A0 a0 D /PF pf D /AT at D /AV av D /AL al D
 /La la D
 /SL SL 1 sub NN D /CF 0 D /FN 0 D SZ SL get FR SL get FS Wf not{()F2}if
 PL 2 ge{Ms E restore Ms or /Ms E D PH 1 eq PH 2 eq or
  {/LM E D}if PH 3 ge{/CI 0 D NL 0 E neg R}if
 }if
 /PL PL 1 sub D /CI 0 D /BP f D /PO f D () Bm 21 get Ts mul BE BL %CF CS SF
} D
/printcap{
 capalg 0 ge{
  SA{/W w Sf div D}
   {talign 1 eq{/XO xo ll twidth sub 2 div add D}if
    talign 2 eq{/XO xo ll twidth sub add D}if
    /W XO twidth add D
   }ie /XO xo D /LL W XO sub MR sub D
  /PA f D /Fl capalg 0 eq D
  1 NA BL caption exec BN OA /PA t D
 }if
} D
/getwid{
 /irow1 E D
 /irow2 irow1 D
 /rwid 0 D
 {rdesc irow2 get dup 0 get rwid add /rwid E D 2 get 0 eq
  {exit}{/irow2 irow2 1 add D}ie
 }loop
} D
/printrow{
 /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
 /xleft xoff xo add D
 /irow E D
 /cells rdesc irow get 6 get D
 0 1 ncol{
  /icol E D
  /cell cells icol get D
  cell 0 ne{
   cell aload pop /ang E D /CB E D /cvsize E D /above E D /fontsz E D
   /DV E D /bot E D /top E D /right E D /left E D /nowrap E D /valign E D
   /dp E D /align E D /rspan E D /cspan E D /cclass E D /ctype E D /cmax E D
   /cmin E D /proc E D
   rspan 0 eq{/rspan nrow irow sub 1 add D}if
   cspan 0 eq{/cspan ncol icol sub 1 add D}if
   /width 0 D
   0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
   /rhight rdesc irow get 0 get D
   /hight rhight D
   1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
   /W xo xoff add width add right sub D
   ang 0 ne{/W xo xoff add hight add right sub D}if
   /EO xo xoff add left add D SI
   Cf{
    gsave CB VC xo xoff add ycur yoff add M
    0 hight neg RL width 0 RL 0 hight RL width neg 0 RL fill
    grestore
   }if
   ctype 1 eq{() BD}if
   /A0 align D RC
   AT 4 eq{
    /DC dp D /ID 1 D /DO cdesc icol get 5 get D /Lo DO DV 0 get sub D /L1 Lo D
   }if
   ang 0 ne{
    gsave ang 90 eq
     {xoff ycur add hight cvsize sub 2 div sub ycur hight sub xoff sub}
     {xoff ycur sub width add hight cvsize sub 2 div add ycur xoff add}ie
    translate ang rotate
   }if
   valign 3 le{0 ycur yoff add top sub
    hight cvsize sub valign 1 sub mul 2 div sub M}
   {0 ycur yoff add top sub above add rdesc irow get 4 get sub M}ie
   /PA f D /BP t D /Fl t D
   BL proc exec BN
   ang 0 ne{grestore}if
   /PA t D
   ctype 1 eq{() ES}if
  }if
  /xoff xoff cdesc icol get 0 get add D
 }for
 /yoff yoff rhight sub D
} D
/printhead {0 1 nhead 1 sub{printrow}for} D
/printfoot {nhead 1 nhead nfoot add 1 sub{printrow}for} D
/Tf {
 OU{rules 2 ge{/yoff 0 D
   gsave 0 Sg
   [0 1 nhead 1 sub{}for rbeg 1 row 1 sub{}for nhead 1 nhead nfoot add 1 sub{}for]{
    /irow E D
    /xoff ll twidth PL 2 ge{Sf div}if sub talign mul 2 div D
    /cells rdesc irow get 6 get D
    0 1 ncol{
     /icol E D
     /cell cells icol get D
     cell 0 ne{
      /rspan cell 6 get D
      /cspan cell 5 get D
      rspan 0 eq{/rspan nrow irow sub 1 add D}if
      cspan 0 eq{/cspan ncol icol sub 1 add D}if
      /width 0 D
      0 1 cspan 1 sub{icol add cdesc E get 0 get /width E width add D}for
      /rhight rdesc irow get 0 get D
      /hight rhight D
      1 1 rspan 1 sub{irow add rdesc E get 0 get /hight E hight add D}for
      xo xoff add width add ycur yoff add M
      0 hight neg icol cspan add 1 sub ncol lt
       {cdesc icol 1 add get 4 get dup rules 3 le{1 eq}{pop t}ie
        {1 eq{0.8}{0.3}ie
        LW RL CP stroke M}{pop R}ie}{R}ie
      irow nhead nfoot add 1 sub ne nfoot 0 eq or
       {irow rspan add 1 sub nrow lt
       {rdesc irow rspan add get 3 get}{nfoot 0 eq{0}{1}ie}ie
       dup rules 2 mod 0 eq{1 eq}{pop t}ie
       {1 eq irow rspan add nhead eq or irow rspan add row eq nfoot 0 gt and or
        {0.8}{0.3}ie LW width neg 0 RL CP stroke M}{pop}ie}if
     }if
     /xoff xoff cdesc icol get 0 get add D
    }for
    /yoff yoff rhight sub D
   }forall
   grestore
   /Ms t D
  }if
  frame 1 gt{
   gsave
   1 LW 0 Sg
   xleft ycur M CP BB
   0 yoff frame 5 eq frame 7 ge or{RL}{R}ie
   twidth 0 frame 3 eq frame 4 eq or frame 8 ge or{RL}{R}ie CP BB
   0 yoff neg frame 6 ge{RL}{R}ie
   twidth neg 0 frame 2 eq frame 4 eq or frame 8 ge or{RL}{R}ie
   closepath stroke
   grestore
   /Ms t D
  }if
 }if
} D
/tables [[[0 0 0 0 0 -1 0 0 1 58 2 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()1 Sl()WB(XML Schema type)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(Alias in the )SM(xml_schema)ES( names)HY(pace)YH()} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(C++ type
    )} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(anyType and anySim)HY(ple)HY(Type)YH( types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(anyType)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(type)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 24 1 A(Section 2.5.2, "Mapping for )SM(anyType)ES(")24 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(anySim)HY(ple)HY(Type)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(simple_type)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 25 1 A(Section 2.5.3, "Mapping for )SM(anySim)HY(ple)HY(Type)YH()ES(")25 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(fixed-length inte)HY(gral)YH( types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(byte)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(byte)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(signed\240char)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(unsigned)HY(Byte)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned_byte)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned\240char)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(short)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(short_)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(short)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(unsigned)HY(Short)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned_short)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned\240short)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(int)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(int_)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(int)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(unsignedInt)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned_int)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned\240int)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(long)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(long_)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(unsigned)HY(Long)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned_long)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned\240long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(arbi)HY(trary)YH(-length inte)HY(gral)YH( types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(nonPos)HY(i)HY(tiveIn)HY(te)HY(ger)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(non_posi)HY(tive)YH(_integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(nonNeg)HY(a)HY(tiveIn)HY(te)HY(ger)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(non_nega)HY(tive)YH(_integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(posi)HY(tiveIn)HY(te)HY(ger)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(posi)HY(tive)YH(_integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(unsigned long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(nega)HY(tiveIn)HY(te)HY(ger)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(nega)HY(tive)YH(_integer)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(long\240long)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(boolean types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(boolean)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(boolean)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(bool)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(fixed-preci)HY(sion)YH( float)HY(ing)YH(-point types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(float)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(float_)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(float)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(double)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(double_)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(double)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(arbi)HY(trary)YH(-preci)HY(sion)YH( float)HY(ing)YH(-point types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(decimal)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(decimal)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(double)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(string types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(string)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(string)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(std::basic_string)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(normal)HY(ized)HY(String)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(normal)HY(ized)YH(_string)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(string)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(token)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(token)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type\240derived\240from\240)SM(normal)HY(ized)YH(_string)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(Name)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(name)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(token)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(NMTOKEN)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(nmtoken)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(token)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(NMTO)HY(KENS)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(nmto)HY(kens)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(sequence<nmtoken>)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(NCName)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(ncname)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(name)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(language)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(language)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(token)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(qual)HY(i)HY(fied)YH( name
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(QName)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(qname)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 26 1 A(Section 2.5.4, "Mapping for )SM(QName)ES(")26 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(ID/IDREF types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(ID)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(id)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(ncname)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(IDREF)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(idref)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 27 1 A(Section 2.5.5, "Mapping for )SM(IDREF)ES(")27 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(IDREFS)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(idrefs)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(sequence<idref>)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(URI types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(anyURI)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(uri)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(std::basic_string)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(binary types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 1 0 0 0 [[{()1 Sl()WB()SM(base64Binary)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(base64_binary)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 28 1 A(Section 2.5.6, "Mapping for
         )SM(base64Binary)ES( and )SM(hexBi)HY(nary)YH()ES(")28 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 2 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(hexBi)HY(nary)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(hex_binary)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(date/time types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(date)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(date)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 30 1 A(Section 2.5.8, "Mapping for
          )SM(date)ES(")30 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(date)HY(Time)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(date_time)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 31 1 A(Section 2.5.9, "Mapping for
          )SM(date)HY(Time)YH()ES(")31 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(dura)HY(tion)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(dura)HY(tion)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 32 1 A(Section 2.5.10, "Mapping for
          )SM(dura)HY(tion)YH()ES(")32 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(gDay)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(gday)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 33 1 A(Section 2.5.11, "Mapping for
          )SM(gDay)ES(")33 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(gMonth)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(gmonth)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 34 1 A(Section 2.5.12, "Mapping for
          )SM(gMonth)ES(")34 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(gMon)HY(th)HY(Day)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(gmonth_day)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 35 1 A(Section 2.5.13, "Mapping for
          )SM(gMon)HY(th)HY(Day)YH()ES(")35 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(gYear)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(gyear)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 36 1 A(Section 2.5.14, "Mapping for
          )SM(gYear)ES(")36 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(gYear)HY(Month)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(gyear_month)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 37 1 A(Section 2.5.15, "Mapping for
          )SM(gYear)HY(Month)YH()ES(")37 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(time)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(time)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()0 38 1 A(Section 2.5.16, "Mapping for
          )SM(time)ES(")38 0 TN TL()Ec /AF f D(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB(entity types
    )} 0 0 1 0 3 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
0
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(ENTITY)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(entity)ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(name)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 0 0 0 0 [[{()1 Sl()WB()SM(ENTI)HY(TIES)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()SM(enti)HY(ties)YH()ES()} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(type derived from )SM(sequence<entity>)ES(
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
]]
[[0 0 0 0 0 -1 0 0 1 8 5 0 0 9 5 {()} -1]
 [[0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0][0 0 0 0 0 0 0]]
 [[0 0 0 0 0 0 [[{()1 Sl()WB()} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB()} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(default)} 0 0 1 0 2 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
[{()1 Sl()WB(fixed
    )} 0 0 1 0 2 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
[0 0 1 0 0 0 [[{()1 Sl()WB(element)} 0 0 1 0 1 4 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(not present)} 0 0 1 0 1 2 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(optional)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(required)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(optional)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(required
    )} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 1 0 0 0 [0
0
[{()1 Sl()WB(not present)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(invalid instance)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(not present)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(invalid instance
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 1 0 0 0 [0
[{()1 Sl()WB(empty)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(default value is used)} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
[{()1 Sl()WB(fixed value is used
    )} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
[0 0 0 0 0 0 [0
[{()1 Sl()WB(value)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(value is used)} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
[{()1 Sl()WB(value is used provided it's the same as fixed
    )} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
[0 0 1 0 0 0 [[{()1 Sl()WB(attribute)} 0 0 1 0 1 4 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(not present)} 0 0 1 0 1 2 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(optional)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(required)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(optional)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(required
    )} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 1 0 0 0 [0
0
[{()1 Sl()WB(default value is used)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(invalid schema)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(fixed value is used)} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(invalid instance
    )} 0 0 0 0 1 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
]]
[0 0 1 0 0 0 [0
[{()1 Sl()WB(empty)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(empty value is used)} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
[{()1 Sl()WB(empty value is used provided it's the same as fixed
    )} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
[0 0 0 0 0 0 [0
[{()1 Sl()WB(value)} 0 0 1 0 1 1 1 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
[{()1 Sl()WB(value is used)} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
[{()1 Sl()WB(value is used provided it's the same as fixed
    )} 0 0 0 0 2 1 0 (.) 2 0 4 4 2 6 0 0 0 0 Db 0 ]
0
]]
]]
] D
0 1 1{TS}for RC ZF
/Ba f D /BO 0 D Bs
/UR (/home/boris/work/xsd/xsd/doc/cxx/tree/manual/index.xhtml) D
/Ti (C++/Tree Mapping User Manual) D
/Au () D
/Df f D
/ME [(4.0.0)] D
Pt
/BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
 tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(C++/Tree Mapping User Manual)ES()0 1 TN()EA()BN}if
1 NH le{97(1\240\240)1 C(Preface)WB 3 Sn()97 1 TN()EA()BN}if
2 NH le{98(1.1\240\240)2 C(About)WB 4 Sn( This Docu)HY(ment)YH()98 1 TN()EA()BN}if
2 NH le{99(1.2\240\240)2 C(More)WB 5 Sn( Infor)HY(ma)HY(tion)YH()99 1 TN()EA()BN}if
1 NH le{100(2\240\240)1 C(1)WB 6 Sn( Intro)HY(duc)HY(tion)YH()100 1 TN()EA()BN}if
1 NH le{101(3\240\240)1 C(2)WB 7 Sn( C++/Tree Mapping)101 1 TN()EA()BN}if
2 NH le{102(3.1\240\240)2 C(2.1)WB 8 Sn( Prelim)HY(i)HY(nary)YH( Infor)HY(ma)HY(tion)YH()102 1 TN()EA()BN}if
3 NH le{103(3.1.1\240\240)3 C(2.1.1)WB 9 Sn( C++ Stan)HY(dard)YH()103 1 TN()EA()BN}if
3 NH le{104(3.1.2\240\240)3 C(2.1.2)WB 10 Sn( Iden)HY(ti)HY(fiers)YH()104 1 TN()EA()BN}if
3 NH le{105(3.1.3\240\240)3 C(2.1.3)WB 11 Sn( Char)HY(ac)HY(ter)YH( Type and Encod)HY(ing)YH()105 1 TN()EA()BN}if
3 NH le{106(3.1.4\240\240)3 C(2.1.4)WB 12 Sn( XML Schema Names)HY(pace)YH()106 1 TN()EA()BN}if
3 NH le{107(3.1.5\240\240)3 C(2.1.5)WB 13 Sn( Anony)HY(mous)YH( Types)107 1 TN()EA()BN}if
2 NH le{108(3.2\240\240)2 C(2.2)WB 14 Sn( Error Handling)108 1 TN()EA()BN}if
3 NH le{109(3.2.1\240\240)3 C(2.2.1)WB 15 Sn( )SM(xml_schema::dupli)HY(cate)YH(_id)ES()109 1 TN()EA()BN}if
2 NH le{110(3.3\240\240)2 C(2.3)WB 16 Sn( Mapping for )SM(import)ES( and )SM(include)ES()110 1 TN()EA()BN}if
3 NH le{111(3.3.1\240\240)3 C(2.3.1)WB 17 Sn( Import)111 1 TN()EA()BN}if
3 NH le{112(3.3.2\240\240)3 C(2.3.2)WB 18 Sn( Inclu)HY(sion)YH( with Target Names)HY(pace)YH()112 1 TN()EA()BN}if
3 NH le{113(3.3.3\240\240)3 C(2.3.3)WB 19 Sn( Inclu)HY(sion)YH( without Target Names)HY(pace)YH()113 1 TN()EA()BN}if
2 NH le{114(3.4\240\240)2 C(2.4)WB 20 Sn( Mapping for Names)HY(paces)YH()114 1 TN()EA()BN}if
2 NH le{115(3.5\240\240)2 C(2.5)WB 21 Sn( Mapping for Built-in Data Types)115 1 TN()EA()BN}if
3 NH le{116(3.5.1\240\240)3 C(2.5.1)WB 23 Sn( Inher)HY(i)HY(tance)YH( from Built-in Data Types)116 1 TN()EA()BN}if
3 NH le{117(3.5.2\240\240)3 C(2.5.2)WB 24 Sn( Mapping for )SM(anyType)ES()117 1 TN()EA()BN}if
3 NH le{118(3.5.3\240\240)3 C(2.5.3)WB 25 Sn( Mapping for )SM(anySim)HY(ple)HY(Type)YH()ES()118 1 TN()EA()BN}if
3 NH le{119(3.5.4\240\240)3 C(2.5.4)WB 26 Sn( Mapping for )SM(QName)ES()119 1 TN()EA()BN}if
3 NH le{120(3.5.5\240\240)3 C(2.5.5)WB 27 Sn( Mapping for )SM(IDREF)ES()120 1 TN()EA()BN}if
3 NH le{121(3.5.6\240\240)3 C(2.5.6)WB 28 Sn( Mapping for )SM(base64Binary)ES( and
      )SM(hexBi)HY(nary)YH()ES()121 1 TN()EA()BN}if
2 NH le{122(3.6\240\240)2 C(2.5.7)WB 29 Sn( Time Zone Repre)HY(sen)HY(ta)HY(tion)YH()122 1 TN()EA()BN}if
2 NH le{123(3.7\240\240)2 C(2.5.8)WB 30 Sn( Mapping for )SM(date)ES()123 1 TN()EA()BN}if
2 NH le{124(3.8\240\240)2 C(2.5.9)WB 31 Sn( Mapping for )SM(date)HY(Time)YH()ES()124 1 TN()EA()BN}if
2 NH le{125(3.9\240\240)2 C(2.5.10)WB 32 Sn( Mapping for )SM(dura)HY(tion)YH()ES()125 1 TN()EA()BN}if
2 NH le{126(3.10\240\240)2 C(2.5.11)WB 33 Sn( Mapping for )SM(gDay)ES()126 1 TN()EA()BN}if
2 NH le{127(3.11\240\240)2 C(2.5.12)WB 34 Sn( Mapping for )SM(gMonth)ES()127 1 TN()EA()BN}if
2 NH le{128(3.12\240\240)2 C(2.5.13)WB 35 Sn( Mapping for )SM(gMon)HY(th)HY(Day)YH()ES()128 1 TN()EA()BN}if
2 NH le{129(3.13\240\240)2 C(2.5.14)WB 36 Sn( Mapping for )SM(gYear)ES()129 1 TN()EA()BN}if
2 NH le{130(3.14\240\240)2 C(2.5.15)WB 37 Sn( Mapping for )SM(gYear)HY(Month)YH()ES()130 1 TN()EA()BN}if
2 NH le{131(3.15\240\240)2 C(2.5.16)WB 38 Sn( Mapping for )SM(time)ES()131 1 TN()EA()BN}if
2 NH le{132(3.16\240\240)2 C(2.6)WB 39 Sn( Mapping for Simple Types)132 1 TN()EA()BN}if
3 NH le{133(3.16.1\240\240)3 C(2.6.1)WB 40 Sn( Mapping for Deriva)HY(tion)YH( by Restric)HY(tion)YH()133 1 TN()EA()BN}if
3 NH le{134(3.16.2\240\240)3 C(2.6.2)WB 41 Sn( Mapping for Enumer)HY(a)HY(tions)YH()134 1 TN()EA()BN}if
3 NH le{135(3.16.3\240\240)3 C(2.6.3)WB 42 Sn( Mapping for Deriva)HY(tion)YH( by List)135 1 TN()EA()BN}if
3 NH le{136(3.16.4\240\240)3 C(2.6.4)WB 43 Sn( Mapping for Deriva)HY(tion)YH( by Union)136 1 TN()EA()BN}if
2 NH le{137(3.17\240\240)2 C(2.7)WB 44 Sn( Mapping for Complex Types)137 1 TN()EA()BN}if
3 NH le{138(3.17.1\240\240)3 C(2.7.1)WB 45 Sn( Mapping for Deriva)HY(tion)YH( by Exten)HY(sion)YH()138 1 TN()EA()BN}if
3 NH le{139(3.17.2\240\240)3 C(2.7.2)WB 46 Sn( Mapping for Deriva)HY(tion)YH( by Restric)HY(tion)YH()139 1 TN()EA()BN}if
2 NH le{140(3.18\240\240)2 C(2.8)WB 47 Sn( Mapping for Local Elements and Attributes)140 1 TN()EA()BN}if
3 NH le{141(3.18.1\240\240)3 C(2.8.1)WB 48 Sn( Mapping for Members with the One Cardi)HY(nal)HY(ity)YH( Class)141 1 TN()EA()BN}if
3 NH le{142(3.18.2\240\240)3 C(2.8.2)WB 49 Sn( Mapping for Members with the Optional Cardi)HY(nal)HY(ity)YH( Class)142 1 TN()EA()BN}if
3 NH le{143(3.18.3\240\240)3 C(2.8.3)WB 50 Sn( Mapping for Members with the Sequence Cardi)HY(nal)HY(ity)YH( Class)143 1 TN()EA()BN}if
3 NH le{144(3.18.4\240\240)3 C(2.8.4)WB 51 Sn( Element Order)144 1 TN()EA()BN}if
2 NH le{145(3.19\240\240)2 C(2.9)WB 52 Sn( Mapping for Global Elements)145 1 TN()EA()BN}if
3 NH le{146(3.19.1\240\240)3 C(2.9.1)WB 53 Sn( Element Types)146 1 TN()EA()BN}if
3 NH le{147(3.19.2\240\240)3 C(2.9.2)WB 54 Sn( Element Map)147 1 TN()EA()BN}if
2 NH le{148(3.20\240\240)2 C(2.10)WB 55 Sn( Mapping for Global Attributes)148 1 TN()EA()BN}if
2 NH le{149(3.21\240\240)2 C(2.11)WB 56 Sn( Mapping for )SM(xsi:type)ES( and Substi)HY(tu)HY(tion)YH(
      Groups)149 1 TN()EA()BN}if
2 NH le{150(3.22\240\240)2 C(2.12)WB 57 Sn( Mapping for )SM(any)ES( and )SM(anyAt)HY(tribute)YH()ES()150 1 TN()EA()BN}if
3 NH le{151(3.22.1\240\240)3 C(2.12.1)WB 58 Sn( Mapping for )SM(any)ES( with the One Cardi)HY(nal)HY(ity)YH( Class)151 1 TN()EA()BN}if
3 NH le{152(3.22.2\240\240)3 C(2.12.2)WB 59 Sn( Mapping for )SM(any)ES( with the Optional Cardi)HY(nal)HY(ity)YH( Class)152 1 TN()EA()BN}if
3 NH le{153(3.22.3\240\240)3 C(2.12.3)WB 60 Sn( Mapping for )SM(any)ES( with the Sequence Cardi)HY(nal)HY(ity)YH( Class)153 1 TN()EA()BN}if
3 NH le{154(3.22.4\240\240)3 C(2.12.4)WB 61 Sn( Element Wild)HY(card)YH( Order)154 1 TN()EA()BN}if
3 NH le{155(3.22.5\240\240)3 C(2.12.5)WB 62 Sn( Mapping for )SM(anyAt)HY(tribute)YH()ES()155 1 TN()EA()BN}if
2 NH le{156(3.23\240\240)2 C(2.13)WB 63 Sn( Mapping for Mixed Content Models)156 1 TN()EA()BN}if
1 NH le{157(4\240\240)1 C(3)WB 64 Sn( Parsing)157 1 TN()EA()BN}if
2 NH le{158(4.1\240\240)2 C(3.1)WB 65 Sn( Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime)158 1 TN()EA()BN}if
2 NH le{159(4.2\240\240)2 C(3.2)WB 66 Sn( Flags and Prop)HY(er)HY(ties)YH()159 1 TN()EA()BN}if
2 NH le{160(4.3\240\240)2 C(3.3)WB 67 Sn( Error Handling)160 1 TN()EA()BN}if
3 NH le{161(4.3.1\240\240)3 C(3.3.1)WB 68 Sn( )SM(xml_schema::parsing)ES()161 1 TN()EA()BN}if
3 NH le{162(4.3.2\240\240)3 C(3.3.2)WB 69 Sn( )SM(xml_schema::expected_element)ES()162 1 TN()EA()BN}if
3 NH le{163(4.3.3\240\240)3 C(3.3.3)WB 70 Sn( )SM(xml_schema::unex)HY(pected)YH(_element)ES()163 1 TN()EA()BN}if
3 NH le{164(4.3.4\240\240)3 C(3.3.4)WB 71 Sn( )SM(xml_schema::expected_attribute)ES()164 1 TN()EA()BN}if
3 NH le{165(4.3.5\240\240)3 C(3.3.5)WB 72 Sn( )SM(xml_schema::unex)HY(pected)YH(_enumer)HY(a)HY(tor)YH()ES()165 1 TN()EA()BN}if
3 NH le{166(4.3.6\240\240)3 C(3.3.6)WB 73 Sn( )SM(xml_schema::expected_text_content)ES()166 1 TN()EA()BN}if
3 NH le{167(4.3.7\240\240)3 C(3.3.7)WB 74 Sn( )SM(xml_schema::no_type_info)ES()167 1 TN()EA()BN}if
3 NH le{168(4.3.8\240\240)3 C(3.3.8)WB 75 Sn( )SM(xml_schema::not_derived)ES()168 1 TN()EA()BN}if
3 NH le{169(4.3.9\240\240)3 C(3.3.9)WB 76 Sn( )SM(xml_schema::no_prefix_mapping)ES()169 1 TN()EA()BN}if
2 NH le{170(4.4\240\240)2 C(3.4)WB 77 Sn( Reading from a Local File or URI)170 1 TN()EA()BN}if
2 NH le{171(4.5\240\240)2 C(3.5)WB 78 Sn( Reading from )SM(std::istream)ES()171 1 TN()EA()BN}if
2 NH le{172(4.6\240\240)2 C(3.6)WB 79 Sn( Reading from )SM(xercesc::Input)HY(Source)YH()ES()172 1 TN()EA()BN}if
2 NH le{173(4.7\240\240)2 C(3.7)WB 80 Sn( Reading from DOM)173 1 TN()EA()BN}if
1 NH le{174(5\240\240)1 C(4)WB 81 Sn( Seri)HY(al)HY(iza)HY(tion)YH()174 1 TN()EA()BN}if
2 NH le{175(5.1\240\240)2 C(4.1)WB 82 Sn( Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime)175 1 TN()EA()BN}if
2 NH le{176(5.2\240\240)2 C(4.2)WB 83 Sn( Names)HY(pace)YH( Infomap and Char)HY(ac)HY(ter)YH( Encod)HY(ing)YH()176 1 TN()EA()BN}if
2 NH le{177(5.3\240\240)2 C(4.3)WB 84 Sn( Flags)177 1 TN()EA()BN}if
2 NH le{178(5.4\240\240)2 C(4.4)WB 85 Sn( Error Handling)178 1 TN()EA()BN}if
3 NH le{179(5.4.1\240\240)3 C(4.4.1)WB 86 Sn( )SM(xml_schema::seri)HY(al)HY(iza)HY(tion)YH()ES()179 1 TN()EA()BN}if
3 NH le{180(5.4.2\240\240)3 C(4.4.2)WB 87 Sn( )SM(xml_schema::unex)HY(pected)YH(_element)ES()180 1 TN()EA()BN}if
3 NH le{181(5.4.3\240\240)3 C(4.4.3)WB 88 Sn( )SM(xml_schema::no_type_info)ES()181 1 TN()EA()BN}if
2 NH le{182(5.5\240\240)2 C(4.5)WB 89 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to )SM(std::ostream)ES()182 1 TN()EA()BN}if
2 NH le{183(5.6\240\240)2 C(4.6)WB 90 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to )SM(xercesc::XMLFor)HY(mat)HY(Tar)HY(get)YH()ES()183 1 TN()EA()BN}if
2 NH le{184(5.7\240\240)2 C(4.7)WB 91 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to DOM)184 1 TN()EA()BN}if
1 NH le{185(6\240\240)1 C(5)WB 92 Sn( Addi)HY(tional)YH( Func)HY(tion)HY(al)HY(ity)YH()185 1 TN()EA()BN}if
2 NH le{186(6.1\240\240)2 C(5.1)WB 93 Sn( DOM Asso)HY(ci)HY(a)HY(tion)YH()186 1 TN()EA()BN}if
2 NH le{187(6.2\240\240)2 C(5.2)WB 94 Sn( Binary Seri)HY(al)HY(iza)HY(tion)YH()187 1 TN()EA()BN}if
1 NH le{188(7\240\240)1 C(Appendix)WB 95 Sn( A \236 Default and Fixed Values)188 1 TN()EA()BN}if
/OU t D /Cb Db D NP Ep ET 
/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (/home/boris/work/xsd/xsd/doc/cxx/tree/manual/index.xhtml) D
/Ti (C++/Tree Mapping User Manual) D
/Au () D
/Df f D
/ME [(4.0.0)] D

NP RC ZF
()1 Sl()WB 0 Sn(

)BR()WB 1 Sn(  )BR()WB 2 Sn(
  

  )0 1 0 H(Preface)WB 97 Sn()WB 3 Sn()EA()EH(

  )0 2 1 H(About)WB 98 Sn()WB 4 Sn( This Docu)HY(ment)YH()EA()EH(

  )0 P(This docu)HY(ment)YH( describes the mapping of W3C XML Schema
     to the C++ program)HY(ming)YH( language as imple)HY(mented)YH( by
     )R1 2 A(CodeSyn)HY(the)HY(sis)YH(
     XSD)EA( - an XML Schema to C++ data binding compiler. The mapping
     repre)HY(sents)YH( infor)HY(ma)HY(tion)YH( stored in XML instance docu)HY(ments)YH( as a
     stat)HY(i)HY(cally)YH(-typed, tree-like in-memory data struc)HY(ture)YH( and is
     called C++/Tree.
  )EP(

  )0 P(Revi)HY(sion)YH( 4.0.0)BR( 
     This revi)HY(sion)YH( of the manual describes the C++/Tree
     mapping as imple)HY(mented)YH( by CodeSyn)HY(the)HY(sis)YH( XSD version 4.0.0.
  )EP(

  )0 P(This docu)HY(ment)YH( is avail)HY(able)YH( in the follow)HY(ing)YH( formats:
     )R2 2 A(XHTML)EA(,
     )R3 2 A(PDF)EA(, and
     )R4 2 A(PostScript)EA(.)EP(

  )0 2 2 H(More)WB 99 Sn()WB 5 Sn( Infor)HY(ma)HY(tion)YH()EA()EH(

  )0 P(Beyond this manual, you may also find the follow)HY(ing)YH( sources of
     infor)HY(ma)HY(tion)YH( useful:)EP(

  )UL(    )-1 LI()R5 2 A(C++/Tree
        Mapping Getting Started Guide)EA(

    )-1 LI()R6 2 A(C++/Tree
        Mapping Customiza)HY(tion)YH( Guide)EA(

    )-1 LI()R7 2 A(C++/Tree
        Mapping Frequently Asked Ques)HY(tions)YH( \201FAQ\202)EA(

    )-1 LI()R8 2 A(XSD
        Compiler Command Line Manual)EA(

    )-1 LI(The )SM(exam)HY(ples)YH(/cxx/tree/)ES( direc)HY(tory)YH( in the XSD
        distri)HY(bu)HY(tion)YH( contains a collec)HY(tion)YH( of exam)HY(ples)YH( and a README
        file with an overview of each example.

    )-1 LI(The )SM(README)ES( file in the XSD distri)HY(bu)HY(tion)YH( explains
        how to compile the exam)HY(ples)YH( on various plat)HY(forms)YH(.

    )-1 LI(The )R9 2 A(xsd-users)EA(
        mailing list is a place to ask ques)HY(tions)YH(. Further)HY(more)YH( the
        )R10 2 A(archives)EA(
        may already have answers to some of your ques)HY(tions)YH(.
  )LU(


  )0 1 3 H(1)WB 100 Sn()WB 6 Sn( Intro)HY(duc)HY(tion)YH()EA()EH(

  )0 P(C++/Tree is a W3C XML Schema to C++ mapping that repre)HY(sents)YH( the
     data stored in XML as a stat)HY(i)HY(cally)YH(-typed, vocab)HY(u)HY(lary)YH(-specific
     object model. Based on a formal descrip)HY(tion)YH( of an XML vocab)HY(u)HY(lary)YH(
     \201schema\202, the C++/Tree mapping produces a tree-like data struc)HY(ture)YH(
     suit)HY(able)YH( for in-memory process)HY(ing)YH( as well as XML parsing and
     seri)HY(al)HY(iza)HY(tion)YH( code.)EP(

  )0 P(A typical appli)HY(ca)HY(tion)YH( that processes XML docu)HY(ments)YH( usually
     performs the follow)HY(ing)YH( three steps: it first reads \201parses\202 an XML
     instance docu)HY(ment)YH( to an object model, it then performs
     some useful compu)HY(ta)HY(tions)YH( on that model which may involve
     modi)HY(fi)HY(ca)HY(tion)YH( of the model, and finally it may write \201seri)HY(al)HY(ize)YH(\202
     the modi)HY(fied)YH( object model back to XML.
  )EP(

  )0 P(The C++/Tree mapping consists of C++ types that repre)HY(sent)YH( the
     given vocab)HY(u)HY(lary)YH( \201)0 7 1 A(Chapter 2, "C++/Tree Mapping")7 0 TN TL()Ec /AF f D(\202,
     a set of parsing func)HY(tions)YH( that convert XML docu)HY(ments)YH( to
     a tree-like in-memory data struc)HY(ture)YH( \201)0 64 1 A(Chapter 3,
     "Parsing")64 0 TN TL()Ec /AF f D(\202, and a set of seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( that convert
     the object model back to XML \201)0 81 1 A(Chapter 4,
     "Seri)HY(al)HY(iza)HY(tion)YH(")81 0 TN TL()Ec /AF f D(\202. Further)HY(more)YH(, the mapping provides a number
     of addi)HY(tional)YH( features, such as DOM asso)HY(ci)HY(a)HY(tion)YH( and binary
     seri)HY(al)HY(iza)HY(tion)YH(, that can be useful in some appli)HY(ca)HY(tions)YH(
     \201)0 92 1 A(Chapter 5, "Addi)HY(tional)YH( Func)HY(tion)HY(al)HY(ity)YH(")92 0 TN TL()Ec /AF f D(\202.
  )EP(


  


  )0 1 4 H(2)WB 101 Sn()WB 7 Sn( C++/Tree Mapping)EA()EH(

  )0 2 5 H(2.1)WB 102 Sn()WB 8 Sn( Prelim)HY(i)HY(nary)YH( Infor)HY(ma)HY(tion)YH()EA()EH(

  )0 3 6 H(2.1.1)WB 103 Sn()WB 9 Sn( C++ Stan)HY(dard)YH()EA()EH(

  )0 P(The C++/Tree mapping provides support for ISO/IEC C++ 1998/2003 \201C++98\202
     and ISO/IEC C++ 2011 \201C++11\202. To select the C++ stan)HY(dard)YH( for the
     gener)HY(ated)YH( code we use the )SM(--std)ES( XSD compiler command
     line option. While the major)HY(ity)YH( of the exam)HY(ples)YH( in this manual use
     C++98, support for the new func)HY(tion)HY(al)HY(ity)YH( and library compo)HY(nents)YH(
     intro)HY(duced)YH( in C++11 are discussed through)HY(out)YH( the docu)HY(ment)YH(.)EP(

  )0 3 7 H(2.1.2)WB 104 Sn()WB 10 Sn( Iden)HY(ti)HY(fiers)YH()EA()EH(

  )0 P(XML Schema names may happen to be reserved C++ keywords or contain
     char)HY(ac)HY(ters)YH( that are illegal in C++ iden)HY(ti)HY(fiers)YH(. To avoid C++ compi)HY(la)HY(tion)YH(
     prob)HY(lems)YH(, such names are changed \201escaped\202 when mapped to C++. If an
     XML Schema name is a C++ keyword, the "_" suffix is added to it. All
     char)HY(ac)HY(ter)YH( of an XML Schema name that are not allowed in C++ iden)HY(ti)HY(fiers)YH(
     are replaced with "_".
  )EP(

  )0 P(For example, XML Schema name )SM(try)ES( will be mapped to
     C++ iden)HY(ti)HY(fier)YH( )SM(try_)ES(. Simi)HY(larly)YH(, XML Schema name
     )SM(strange.na-me)ES( will be mapped to C++ iden)HY(ti)HY(fier)YH(
     )SM(strange_na_me)ES(.
  )EP(

  )0 P(Further)HY(more)YH(, conflicts between type names and func)HY(tion)YH( names in the
     same scope are resolved using name escap)HY(ing)YH(. Such conflicts include
     both a global element \201which is mapped to a set of parsing and/or
     seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( or element types, see )0 52 1 A(Section
     2.9, "Mapping for Global Elements")52 0 TN TL()Ec /AF f D(\202 and a global type sharing the
     same name as well as a local element or attribute inside a type having
     the same name as the type itself.)EP(

  )0 P(For example, if we had a global type )SM(catalog)ES(
     and a global element with the same name then the type would be
     mapped to a C++ class with name )SM(catalog)ES( while the
     parsing func)HY(tions)YH( corre)HY(spond)HY(ing)YH( to the global element would have
     their names escaped as )SM(catalog_)ES(.
  )EP(

  )0 P(By default the mapping uses the so-called K&R \201Kernighan and
     Ritchie\202 iden)HY(ti)HY(fier)YH( naming conven)HY(tion)YH( which is also used through)HY(out)YH(
     this manual. In this conven)HY(tion)YH( both type and func)HY(tion)YH( names are in
     lower case and words are sepa)HY(rated)YH( by under)HY(scores)YH(. If your appli)HY(ca)HY(tion)YH(
     code or schemas use a differ)HY(ent)YH( nota)HY(tion)YH(, you may want to change the
     naming conven)HY(tion)YH( used by the mapping for consis)HY(tency)YH(.
     The compiler supports a set of widely-used naming conven)HY(tions)YH(
     that you can select with the )SM(--type-naming)ES( and
     )SM(--func)HY(tion)YH(-naming)ES( options. You can also further
     refine one of the prede)HY(fined)YH( conven)HY(tions)YH( or create a completely
     custom naming scheme by using the  )SM(--*-regex)ES( options.
     For more detailed infor)HY(ma)HY(tion)YH( on these options refer to the NAMING
     CONVEN)HY(TION)YH( section in the )R8 2 A(XSD
     Compiler Command Line Manual)EA(.)EP(

  )0 3 8 H(2.1.3)WB 105 Sn()WB 11 Sn( Char)HY(ac)HY(ter)YH( Type and Encod)HY(ing)YH()EA()EH(

  )0 P(The code that imple)HY(ments)YH( the mapping, depend)HY(ing)YH( on the
     )SM(--char-type)ES(  option, is gener)HY(ated)YH( using either
     )SM(char)ES( or )SM(wchar_t)ES( as the char)HY(ac)HY(ter)YH(
     type. In this docu)HY(ment)YH( code samples use symbol )SM(C)ES(
     to refer to the char)HY(ac)HY(ter)YH( type you have selected when trans)HY(lat)HY(ing)YH(
     your schemas, for example )SM(std::basic_string<C>)ES(.
  )EP(

  )0 P(Another aspect of the mapping that depends on the char)HY(ac)HY(ter)YH( type
     is char)HY(ac)HY(ter)YH( encod)HY(ing)YH(. For the )SM(char)ES( char)HY(ac)HY(ter)YH( type
     the default encod)HY(ing)YH( is UTF-8. Other supported encod)HY(ings)YH( are
     ISO-8859-1, Xerces-C++ Local Code Page \201LPC\202, as well as
     custom encod)HY(ings)YH( and can be selected with the
     )SM(--char-encod)HY(ing)YH()ES( command line option.)EP(

  )0 P(For the )SM(wchar_t)ES( char)HY(ac)HY(ter)YH( type the encod)HY(ing)YH( is
     auto)HY(mat)HY(i)HY(cally)YH( selected between UTF-16 and UTF-32/UCS-4 depend)HY(ing)YH(
     on the size of the )SM(wchar_t)ES( type. On some plat)HY(forms)YH(
     \201for example, Windows with Visual C++ and AIX with IBM XL C++\202
     )SM(wchar_t)ES( is 2 bytes long. For these plat)HY(forms)YH( the
     encod)HY(ing)YH( is UTF-16. On other plat)HY(forms)YH( )SM(wchar_t)ES( is 4 bytes
     long and UTF-32/UCS-4 is used.)EP(

  )0 3 9 H(2.1.4)WB 106 Sn()WB 12 Sn( XML Schema Names)HY(pace)YH()EA()EH(

  )0 P(The mapping relies on some prede)HY(fined)YH( types, classes, and func)HY(tions)YH(
     that are logi)HY(cally)YH( defined in the XML Schema names)HY(pace)YH( reserved for
     the XML Schema language \201)SM(http://www.w3.org/2001/XMLSchema)ES(\202.
     By default, this names)HY(pace)YH( is mapped to C++ names)HY(pace)YH(
     )SM(xml_schema)ES(. It is auto)HY(mat)HY(i)HY(cally)YH( acces)HY(si)HY(ble)YH(
     from a C++ compi)HY(la)HY(tion)YH( unit that includes a header file gener)HY(ated)YH(
     from an XML Schema defi)HY(ni)HY(tion)YH(.
  )EP(

  )0 P(Note that, if desired, the default mapping of this names)HY(pace)YH( can be
     changed as described in )0 20 1 A(Section 2.4, "Mapping for
     Names)HY(paces)YH(")20 0 TN TL()Ec /AF f D(.
  )EP(


  )0 3 10 H(2.1.5)WB 107 Sn()WB 13 Sn( Anony)HY(mous)YH( Types)EA()EH(

  )0 P(For the purpose of code gener)HY(a)HY(tion)YH(, anony)HY(mous)YH( types defined in
     XML Schema are auto)HY(mat)HY(i)HY(cally)YH( assigned names that are derived
     from enclos)HY(ing)YH( attributes and elements. Other)HY(wise)YH(, such types
     follows stan)HY(dard)YH( mapping rules for simple and complex type
     defi)HY(ni)HY(tions)YH( \201see )0 39 1 A(Section 2.6, "Mapping for Simple Types")39 0 TN TL()Ec /AF f D(
     and )0 44 1 A(Section 2.7, "Mapping for Complex Types")44 0 TN TL()Ec /AF f D(\202.
     For example, in the follow)HY(ing)YH( schema frag)HY(ment)YH(:
  )EP(

  ) 5 23 PR(<element name="object">
  <complexType>
    ...
  </complexType>
</element>)RP(

  )0 P(The anony)HY(mous)YH( type defined inside element )SM(object)ES( will
     be given name )SM(object)ES(. The compiler has a number of
     options that control the process of anony)HY(mous)YH( type naming. For more
     infor)HY(ma)HY(tion)YH( refer to the )R8 2 A(XSD
     Compiler Command Line Manual)EA(.)EP(


  )0 2 11 H(2.2)WB 108 Sn()WB 14 Sn( Error Handling)EA()EH(

  )0 P(The mapping uses the C++ excep)HY(tion)YH( handling mech)HY(a)HY(nism)YH( as a primary way
     of report)HY(ing)YH( error condi)HY(tions)YH(. All excep)HY(tions)YH( that are spec)HY(i)HY(fied)YH( in
     this mapping derive from )SM(xml_schema::excep)HY(tion)YH()ES( which
     itself is derived from )SM(std::excep)HY(tion)YH()ES(:
  )EP(

  ) 14 60 PR(struct exception: virtual std::exception
{
  friend
  std::basic_ostream<C>&
  operator<< \201std::basic_ostream<C>& os, const exception& e\202
  {
    e.print \201os\202;
    return os;
  }

protected:
  virtual void
  print \201std::basic_ostream<C>&\202 const = 0;
};)RP(

  )0 P(The excep)HY(tion)YH( hier)HY(ar)HY(chy)YH( supports "virtual" )SM(oper)HY(a)HY(tor)YH(<<)ES(
     which allows you to obtain diag)HY(nos)HY(tics)YH( corre)HY(spond)HY(ing)YH( to the thrown
     excep)HY(tion)YH( using the base excep)HY(tion)YH( inter)HY(face)YH(. For example:)EP(

  ) 8 38 PR(try
{
  ...
}
catch \201const xml_schema::exception& e\202
{
  cerr << e << endl;
})RP(

  )0 P(The follow)HY(ing)YH( sub-sections describe excep)HY(tions)YH( thrown by the
     types that consti)HY(tute)YH( the object model.
     )0 67 1 A(Section 3.3, "Error Handling")67 0 TN TL()Ec /AF f D( of
     )0 64 1 A(Chapter 3, "Parsing")64 0 TN TL()Ec /AF f D( describes excep)HY(tions)YH(
     and error handling mech)HY(a)HY(nisms)YH( specific to the parsing func)HY(tions)YH(.
     )0 85 1 A(Section 4.4, "Error Handling")85 0 TN TL()Ec /AF f D( of
     )0 81 1 A(Chapter 4, "Seri)HY(al)HY(iza)HY(tion)YH(")81 0 TN TL()Ec /AF f D( describes excep)HY(tions)YH(
     and error handling mech)HY(a)HY(nisms)YH( specific to the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(.
  )EP(


  )0 3 12 H(2.2.1)WB 109 Sn()WB 15 Sn( )SM(xml_schema::dupli)HY(cate)YH(_id)ES()EA()EH(

  ) 10 48 PR(struct duplicate_id: virtual exception
{
  duplicate_id \201const std::basic_string<C>& id\202;

  const std::basic_string<C>&
  id \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::dupli)HY(cate)YH(_id)ES( is thrown when
     a conflict)HY(ing)YH( instance of )SM(xml_schema::id)ES( \201see
     )0 21 1 A(Section 2.5, "Mapping for Built-in Data Types")21 0 TN TL()Ec /AF f D(\202
     is added to a tree. The offend)HY(ing)YH( ID value can be obtained using
     the )SM(id)ES( func)HY(tion)YH(.
  )EP(

  )0 2 13 H(2.3)WB 110 Sn()WB 16 Sn( Mapping for )SM(import)ES( and )SM(include)ES()EA()EH(

  )0 3 14 H(2.3.1)WB 111 Sn()WB 17 Sn( Import)EA()EH(

  )0 P(The XML Schema )SM(import)ES( element is mapped to the C++
     Prepro)HY(ces)HY(sor)YH( )SM(#include)ES( direc)HY(tive)YH(. The value of
     the )SM(schemaLo)HY(ca)HY(tion)YH()ES( attribute is used to derive
     the name of the header file that appears in the )SM(#include)ES(
     direc)HY(tive)YH(. For instance:
  )EP(

  ) 2 53 PR(<import namespace="http://www.codesynthesis.com/test"
        schemaLocation="test.xsd"/>)RP(

  )0 P(is mapped to:)EP(

  ) 1 19 PR(#include "test.hxx")RP(

  )0 P(Note that you will need to compile imported schemas sepa)HY(rately)YH(
     in order to produce corre)HY(spond)HY(ing)YH( header files.)EP(

  )0 3 15 H(2.3.2)WB 112 Sn()WB 18 Sn( Inclu)HY(sion)YH( with Target Names)HY(pace)YH()EA()EH(

  )0 P(The XML Schema )SM(include)ES( element which refers to a schema
     with a target names)HY(pace)YH( or appears in a schema without a target names)HY(pace)YH(
     follows the same mapping rules as the )SM(import)ES( element,
     see )0 17 1 A(Section 2.3.1, "Import")17 0 TN TL()Ec /AF f D(.
  )EP(

  )0 3 16 H(2.3.3)WB 113 Sn()WB 19 Sn( Inclu)HY(sion)YH( without Target Names)HY(pace)YH()EA()EH(

  )0 P(For the XML Schema )SM(include)ES( element which refers to a schema
     without a target names)HY(pace)YH( and appears in a schema with a target
     names)HY(pace)YH( \201such inclu)HY(sion)YH( some)HY(times)YH( called "chameleon inclu)HY(sion)YH("\202,
     decla)HY(ra)HY(tions)YH( and defi)HY(ni)HY(tions)YH( from the included schema are gener)HY(ated)YH(
     in-line in the names)HY(pace)YH( of the includ)HY(ing)YH( schema as if they were
     declared and defined there verba)HY(tim)YH(. For example, consider the
     follow)HY(ing)YH( two schemas:
  )EP(

  ) 11 60 PR(<-- common.xsd -->
<schema>
  <complexType name="type">
  ...
  </complexType>
</schema>

<-- test.xsd -->
<schema targetNamespace="http://www.codesynthesis.com/test">
  <include schemaLocation="common.xsd"/>
</schema>)RP(

  )0 P(The frag)HY(ment)YH( of inter)HY(est)YH( from the gener)HY(ated)YH( header file for
     )SM(text.xsd)ES( would look like this:)EP(

  ) 8 14 PR(// test.hxx
namespace test
{
  class type
  {
    ...
  };
})RP(

  )0 2 17 H(2.4)WB 114 Sn()WB 20 Sn( Mapping for Names)HY(paces)YH()EA()EH(

  )0 P(An XML Schema names)HY(pace)YH( is mapped to one or more nested C++
     names)HY(paces)YH(. XML Schema names)HY(paces)YH( are iden)HY(ti)HY(fied)YH( by URIs.
     By default, a names)HY(pace)YH( URI is mapped to a sequence of
     C++ names)HY(pace)YH( names by remov)HY(ing)YH( the proto)HY(col)YH( and host parts
     and split)HY(ting)YH( the rest into a sequence of names with ')SM(/)ES('
     as the name sepa)HY(ra)HY(tor)YH(. For instance:
  )EP(

  ) 3 67 PR(<schema targetNamespace="http://www.codesynthesis.com/system/test">
  ...
</schema>)RP(

  )0 P(is mapped to:)EP(

  ) 7 16 PR(namespace system
{
  namespace test
  {
    ...
  }
})RP(

  )0 P(The default mapping of names)HY(pace)YH( URIs to C++ names)HY(pace)YH( names can be
     altered using the )SM(--names)HY(pace)YH(-map)ES( and
     )SM(--names)HY(pace)YH(-regex)ES( options. See  the
     )R8 2 A(XSD
     Compiler Command Line Manual)EA( for more infor)HY(ma)HY(tion)YH(.
  )EP(

  )0 2 18 H(2.5)WB 115 Sn()WB 21 Sn( Mapping for Built-in Data Types)EA()EH(

  )0 P(The mapping of XML Schema built-in data types to C++ types is
     summa)HY(rized)YH( in the table below.)EP(

  
  )0 PT(

  )0 P(All XML Schema built-in types are mapped to C++ classes that are
     derived from the )SM(xml_schema::simple_type)ES( class except
     where the mapping is to a funda)HY(men)HY(tal)YH( C++ type.)EP(

  )0 P(The )SM(sequence)ES( class template is defined in an
     imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH(. It conforms to the
     sequence inter)HY(face)YH( as defined by the ISO/ANSI Stan)HY(dard)YH( for
     C++ \201ISO/IEC 14882:1998, Section 23.1.1, "Sequences"\202.
     Prac)HY(ti)HY(cally)YH(, this means that you can treat such a sequence
     as if it was )SM(std::vector)ES(. One notable exten)HY(sion)YH(
     to the stan)HY(dard)YH( inter)HY(face)YH( that is avail)HY(able)YH( only for
     sequences of non-funda)HY(men)HY(tal)YH( C++ types is the addi)HY(tion)YH( of
     the over)HY(loaded)YH( )SM(push_back)ES( and )SM(insert)ES(
     member func)HY(tions)YH( which instead of the constant refer)HY(ence)YH(
     to the element type accept auto)HY(matic)YH( pointer \201)SM(std::auto_ptr)ES(
     or )SM(std::unique_ptr)ES(, depend)HY(ing)YH( on the C++ stan)HY(dard)YH(
     selected\202 to the element type. These func)HY(tions)YH( assume owner)HY(ship)YH(
     of the pointed to object and reset the passed auto)HY(matic)YH( pointer.
  )EP(

  )0 3 19 H(2.5.1)WB 116 Sn()WB 23 Sn( Inher)HY(i)HY(tance)YH( from Built-in Data Types)EA()EH(

  )0 P(In cases where the mapping calls for an inher)HY(i)HY(tance)YH( from a built-in
     type which is mapped to a funda)HY(men)HY(tal)YH( C++ type, a proxy type is
     used instead of the funda)HY(men)HY(tal)YH( C++ type \201C++ does not allow
     inher)HY(i)HY(tance)YH( from funda)HY(men)HY(tal)YH( types\202. For instance:)EP(

  ) 3 27 PR(<simpleType name="my_int">
  <restriction base="int"/>
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 4 42 PR(class my_int: public fundamental_base<int>
{
  ...
};)RP(

  )0 P(The )SM(funda)HY(men)HY(tal)YH(_base)ES( class template provides a close
     emula)HY(tion)YH( \201though not exact\202 of a funda)HY(men)HY(tal)YH( C++ type.
     It is defined in an imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH( and has the
     follow)HY(ing)YH( inter)HY(face)YH(:)EP(

  ) 22 44 PR(template <typename X>
class fundamental_base: public simple_type
{
public:
  fundamental_base \201\202;
  fundamental_base \201X\202
  fundamental_base \201const fundamental_base&\202

public:
  fundamental_base&
  operator= \201const X&\202;

public:
  operator const X & \201\202 const;
  operator X& \201\202;

  template <typename Y>
  operator Y \201\202 const;

  template <typename Y>
  operator Y \201\202;
};)RP(

  )0 3 20 H(2.5.2)WB 117 Sn()WB 24 Sn( Mapping for )SM(anyType)ES()EA()EH(

  )0 P(The XML Schema )SM(anyType)ES( built-in data type is mapped to the
     )SM(xml_schema::type)ES( C++ class:)EP(

  ) 53 48 PR(class type
{
public:
  virtual
  ~type \201\202;

  type \201\202;
  type \201const type&\202;

  type&
  operator= \201const type&\202;

  virtual type*
  _clone \201\202 const;

  // anyType DOM content.
  //
public:
  typedef element_optional dom_content_optional;

  const dom_content_optional&
  dom_content \201\202 const;

  dom_content_optional&
  dom_content \201\202;

  void
  dom_content \201const xercesc::DOMElement&\202;

  void
  dom_content \201xercesc::DOMElement*\202;)WR(

  void
  dom_content \201const dom_content_optional&\202;

  const xercesc::DOMDocument&
  dom_content_document \201\202 const;

  xercesc::DOMDocument&
  dom_content_document \201\202;

  bool
  null_content \201\202 const;

  // DOM association.
  //
public:
  const xercesc::DOMNode*
  _node \201\202 const;

  xercesc::DOMNode*
  _node \201\202;
};)RP(

  )0 P(When )SM(xml_schema::type)ES( is used to create an instance
     \201as opposed to being a base of a derived type\202, it repre)HY(sents)YH(
     the XML Schema )SM(anyType)ES( type. )SM(anyType)ES(
     allows any attributes and any content in any order. In the
     C++/Tree mapping this content can be repre)HY(sented)YH( as a DOM
     frag)HY(ment)YH(, similar to XML Schema wild)HY(cards)YH( \201)0 57 1 A(Section
     2.12, "Mapping for )SM(any)ES( and
     )SM(anyAt)HY(tribute)YH()ES(")57 0 TN TL()Ec /AF f D(\202.)EP(

  )0 P(To enable auto)HY(matic)YH( extrac)HY(tion)YH( of )SM(anyType)ES( content
     during parsing, the )SM(--gener)HY(ate)YH(-any-type)ES( option must be
     spec)HY(i)HY(fied)YH(. Because the DOM API is used to access such content, the
     Xerces-C++ runtime should be initial)HY(ized)YH( by the appli)HY(ca)HY(tion)YH( prior to
     parsing and should remain initial)HY(ized)YH( for the life)HY(time)YH( of objects
     with the DOM content. For more infor)HY(ma)HY(tion)YH( on the Xerces-C++ runtime
     initial)HY(iza)HY(tion)YH( see )0 65 1 A(Section 3.1, "Initial)HY(iz)HY(ing)YH( the
     Xerces-C++ Runtime")65 0 TN TL()Ec /AF f D(.)EP(

  )0 P(The DOM content is stored as the optional DOM element container
     and the DOM content acces)HY(sors)YH( and modi)HY(fiers)YH( presented above are
     iden)HY(ti)HY(cal)YH( to those gener)HY(ated)YH( for an optional element wild)HY(card)YH(.
     Refer to )0 59 1 A(Section 2.12.2, "Mapping for )SM(any)ES(
     with the Optional Cardi)HY(nal)HY(ity)YH( Class")59 0 TN TL()Ec /AF f D( for details on their
     seman)HY(tics)YH(.)EP(

  )0 P(The )SM(dom_content_docu)HY(ment)YH(\201\202)ES( func)HY(tion)YH( returns the
     DOM docu)HY(ment)YH( used to store the raw XML content corre)HY(spond)HY(ing)YH(
     to the )SM(anyType)ES( instance. It is equiv)HY(a)HY(lent)YH( to the
     )SM(dom_docu)HY(ment)YH(\201\202)ES( func)HY(tion)YH( gener)HY(ated)YH( for types
     with wild)HY(cards)YH(.)EP(

  )0 P(The )SM(null_content\201\202)ES( acces)HY(sor)YH( is an opti)HY(miza)HY(tion)YH( func)HY(tion)YH(
     that allows us to check for the lack of content without actu)HY(ally)YH(
     creat)HY(ing)YH( its empty repre)HY(sen)HY(ta)HY(tion)YH(, that is, empty DOM docu)HY(ment)YH( for
     )SM(anyType)ES( or empty string for )SM(anySim)HY(ple)HY(Type)YH()ES(
     \201see the follow)HY(ing)YH( section for details on )SM(anySim)HY(ple)HY(Type)YH()ES(\202.)EP(

  )0 P(For more infor)HY(ma)HY(tion)YH( on DOM asso)HY(ci)HY(a)HY(tion)YH( refer to
     )0 93 1 A(Section 5.1, "DOM Asso)HY(ci)HY(a)HY(tion)YH(")93 0 TN TL()Ec /AF f D(.)EP(

  )0 3 21 H(2.5.3)WB 118 Sn()WB 25 Sn( Mapping for )SM(anySim)HY(ple)HY(Type)YH()ES()EA()EH(

  )0 P(The XML Schema )SM(anySim)HY(ple)HY(Type)YH()ES( built-in data type is mapped
     to the )SM(xml_schema::simple_type)ES( C++ class:)EP(

  ) 27 45 PR(class simple_type: public type
{
public:
  simple_type \201\202;
  simple_type \201const C*\202;
  simple_type \201const std::basic_string<C>&\202;

  simple_type \201const simple_type&\202;

  simple_type&
  operator= \201const simple_type&\202;

  virtual simple_type*
  _clone \201\202 const;

  // anySimpleType text content.
  //
public:
  const std::basic_string<C>&
  text_content \201\202 const;

  std::basic_string<C>&
  text_content \201\202;

  void
  text_content \201const std::basic_string<C>&\202;
};)RP(

  )0 P(When )SM(xml_schema::simple_type)ES( is used to create an instance
     \201as opposed to being a base of a derived type\202, it repre)HY(sents)YH(
     the XML Schema )SM(anySim)HY(ple)HY(Type)YH()ES( type. )SM(anySim)HY(ple)HY(Type)YH()ES(
     allows any simple content. In the C++/Tree mapping this content can
     be repre)HY(sented)YH( as a string and accessed or modi)HY(fied)YH( with the
     )SM(text_content\201\202)ES( func)HY(tions)YH( shown above.)EP(

  )0 3 22 H(2.5.4)WB 119 Sn()WB 26 Sn( Mapping for )SM(QName)ES()EA()EH(

  )0 P(The XML Schema )SM(QName)ES( built-in data type is mapped to the
     )SM(xml_schema::qname)ES( C++ class:)EP(

  ) 25 36 PR(class qname: public simple_type
{
public:
  qname \201const ncname&\202;
  qname \201const uri&, const ncname&\202;
  qname \201const qname&\202;

public:
  qname&
  operator= \201const qname&\202;

public:
  virtual qname*
  _clone \201\202 const;

public:
  bool
  qualified \201\202 const;

  const uri&
  namespace_ \201\202 const;

  const ncname&
  name \201\202 const;
};)RP(

  )0 P(The )SM(qual)HY(i)HY(fied)YH()ES( acces)HY(sor)YH( func)HY(tion)YH( can be used to deter)HY(mine)YH(
     if the name is qual)HY(i)HY(fied)YH(.)EP(

  )0 3 23 H(2.5.5)WB 120 Sn()WB 27 Sn( Mapping for )SM(IDREF)ES()EA()EH(

  )0 P(The XML Schema )SM(IDREF)ES( built-in data type is mapped to the
     )SM(xml_schema::idref)ES( C++ class. This class imple)HY(ments)YH( the
     smart pointer C++ idiom:)EP(

  ) 56 44 PR(class idref: public ncname
{
public:
  idref \201const C* s\202;
  idref \201const C* s, std::size_t n\202;
  idref \201std::size_t n, C c\202;
  idref \201const std::basic_string<C>&\202;
  idref \201const std::basic_string<C>&,
         std::size_t pos,
         std::size_t n = npos\202;

public:
  idref \201const idref&\202;

public:
  virtual idref*
  _clone \201\202 const;

public:
  idref&
  operator= \201C c\202;

  idref&
  operator= \201const C* s\202;

  idref&
  operator= \201const std::basic_string<C>&\202

  idref&
  operator= \201const idref&\202;
)WR(
public:
  const type*
  operator-> \201\202 const;

  type*
  operator-> \201\202;

  const type&
  operator* \201\202 const;

  type&
  operator* \201\202;

  const type*
  get \201\202 const;

  type*
  get \201\202;

  // Conversion to bool.
  //
public:
  typedef void \201idref::*bool_convertible\202\201\202;
  operator bool_convertible \201\202 const;
};)RP(

  )0 P(The object, )SM(idref)ES( instance refers to, is the imme)HY(di)HY(ate)YH(
     container of the match)HY(ing)YH( )SM(id)ES( instance. For example,
     with the follow)HY(ing)YH( instance docu)HY(ment)YH( and schema:
  )EP(


  ) 22 49 PR(<!-- test.xml -->
<root>
  <object id="obj-1" text="hello"/>
  <reference>obj-1</reference>
</root>

<!-- test.xsd -->
<schema>
  <complexType name="object_type">
    <attribute name="id" type="ID"/>
    <attribute name="text" type="string"/>
  </complexType>

  <complexType name="root_type">
    <sequence>
      <element name="object" type="object_type"/>
      <element name="reference" type="IDREF"/>
    </sequence>
  </complexType>

  <element name="root" type="root_type"/>
</schema>)RP(

  )0 P(The )SM(ref)ES( instance in the code below will refer to
     an object of type )SM(object_type)ES(:)EP(

  ) 4 53 PR(root_type& root = ...;
xml_schema::idref& ref \201root.reference \201\202\202;
object_type& obj \201dynamic_cast<object_type&> \201*ref\202\202;
cout << obj.text \201\202 << endl;)RP(

  )0 P(The smart pointer inter)HY(face)YH( of the )SM(idref)ES( class always
     returns a pointer or refer)HY(ence)YH( to )SM(xml_schema::type)ES(.
     This means that you will need to manu)HY(ally)YH( cast such pointer or
     refer)HY(ence)YH( to its real \201dynamic\202 type before you can use it \201unless
     all you need is the base inter)HY(face)YH( provided by
     )SM(xml_schema::type)ES(\202. As a special exten)HY(sion)YH( to the XML
     Schema language, the mapping supports static typing of )SM(idref)ES(
     refer)HY(ences)YH( by employ)HY(ing)YH( the )SM(refType)ES( exten)HY(sion)YH( attribute.
     The follow)HY(ing)YH( example illus)HY(trates)YH( this mech)HY(a)HY(nism)YH(:
  )EP(

  ) 11 72 PR(<!-- test.xsd -->
<schema
  xmlns:xse="http://www.codesynthesis.com/xmlns/xml-schema-extension">

  ...

      <element name="reference" type="IDREF" xse:refType="object_type"/>

  ...

</schema>)RP(

  )0 P(With this modi)HY(fi)HY(ca)HY(tion)YH( we do not need to do manual casting anymore:
  )EP(

  ) 4 51 PR(root_type& root = ...;
root_type::reference_type& ref \201root.reference \201\202\202;
object_type& obj \201*ref\202;
cout << ref->text \201\202 << endl;)RP(


  )0 3 24 H(2.5.6)WB 121 Sn()WB 28 Sn( Mapping for )SM(base64Binary)ES( and
      )SM(hexBi)HY(nary)YH()ES()EA()EH(

  )0 P(The XML Schema )SM(base64Binary)ES( and )SM(hexBi)HY(nary)YH()ES(
     built-in data types are mapped to the
     )SM(xml_schema::base64_binary)ES( and
     )SM(xml_schema::hex_binary)ES( C++ classes, respec)HY(tively)YH(. The
     )SM(base64_binary)ES( and )SM(hex_binary)ES( classes
     support a simple buffer abstrac)HY(tion)YH( by inher)HY(it)HY(ing)YH( from the
     )SM(xml_schema::buffer)ES( class:
  )EP(

  ) 64 58 PR(class bounds: public virtual exception
{
public:
  virtual const char*
  what \201\202 const throw \201\202;
};

class buffer
{
public:
  typedef std::size_t size_t;

public:
  buffer \201size_t size = 0\202;
  buffer \201size_t size, size_t capacity\202;
  buffer \201const void* data, size_t size\202;
  buffer \201const void* data, size_t size, size_t capacity\202;
  buffer \201void* data,
          size_t size,
          size_t capacity,
          bool assume_ownership\202;

public:
  buffer \201const buffer&\202;

  buffer&
  operator= \201const buffer&\202;

  void
  swap \201buffer&\202;
)WR(
public:
  size_t
  capacity \201\202 const;

  bool
  capacity \201size_t\202;

public:
  size_t
  size \201\202 const;

  bool
  size \201size_t\202;

public:
  const char*
  data \201\202 const;

  char*
  data \201\202;

  const char*
  begin \201\202 const;

  char*
  begin \201\202;

  const char*
  end \201\202 const;
)WR(
  char*
  end \201\202;
};)RP(

  )0 P(The last over)HY(loaded)YH( construc)HY(tor)YH( reuses an exist)HY(ing)YH( data buffer instead
     of making a copy. If the )SM(assume_owner)HY(ship)YH()ES( argu)HY(ment)YH( is
     )SM(true)ES(, the instance assumes owner)HY(ship)YH( of the
     memory block pointed to by the )SM(data)ES( argu)HY(ment)YH( and will
     even)HY(tu)HY(ally)YH( release it by calling )SM(oper)HY(a)HY(tor)YH( delete)ES(. The
     )SM(capac)HY(ity)YH()ES( and )SM(size)ES( modi)HY(fier)YH( func)HY(tions)YH( return
     )SM(true)ES( if the under)HY(ly)HY(ing)YH( buffer has moved.
  )EP(

  )0 P(The )SM(bounds)ES( excep)HY(tion)YH( is thrown if the construc)HY(tor)YH(
     argu)HY(ments)YH( violate the )SM(\201size\240<=\240capac)HY(ity)YH(\202)ES(
     constraint.)EP(

  )0 P(The )SM(base64_binary)ES( and )SM(hex_binary)ES( classes
     support the )SM(buffer)ES( inter)HY(face)YH( and perform auto)HY(matic)YH(
     decod)HY(ing)YH(/encod)HY(ing)YH( from/to the Base64 and Hex formats, respec)HY(tively)YH(:
  )EP(

  ) 25 65 PR(class base64_binary: public simple_type, public buffer
{
public:
  base64_binary \201size_t size = 0\202;
  base64_binary \201size_t size, size_t capacity\202;
  base64_binary \201const void* data, size_t size\202;
  base64_binary \201const void* data, size_t size, size_t capacity\202;
  base64_binary \201void* data,
                 size_t size,
                 size_t capacity,
                 bool assume_ownership\202;

public:
  base64_binary \201const base64_binary&\202;

  base64_binary&
  operator= \201const base64_binary&\202;

  virtual base64_binary*
  _clone \201\202 const;

public:
  std::basic_string<C>
  encode \201\202 const;
};)RP(

  ) 25 62 PR(class hex_binary: public simple_type, public buffer
{
public:
  hex_binary \201size_t size = 0\202;
  hex_binary \201size_t size, size_t capacity\202;
  hex_binary \201const void* data, size_t size\202;
  hex_binary \201const void* data, size_t size, size_t capacity\202;
  hex_binary \201void* data,
              size_t size,
              size_t capacity,
              bool assume_ownership\202;

public:
  hex_binary \201const hex_binary&\202;

  hex_binary&
  operator= \201const hex_binary&\202;

  virtual hex_binary*
  _clone \201\202 const;

public:
  std::basic_string<C>
  encode \201\202 const;
};)RP(


  )0 2 25 H(2.5.7)WB 122 Sn()WB 29 Sn( Time Zone Repre)HY(sen)HY(ta)HY(tion)YH()EA()EH(

  )0 P(The )SM(date)ES(, )SM(date)HY(Time)YH()ES(, )SM(gDay)ES(,
     )SM(gMonth)ES(, )SM(gMon)HY(th)HY(Day)YH()ES(, )SM(gYear)ES(,
     )SM(gYear)HY(Month)YH()ES(, and )SM(time)ES( XML Schema built-in
     types all include an optional time zone compo)HY(nent)YH(. The follow)HY(ing)YH(
     )SM(xml_schema::time_zone)ES( base class is used to repre)HY(sent)YH(
     this infor)HY(ma)HY(tion)YH(:)EP(

  ) 30 48 PR(class time_zone
{
public:
  time_zone \201\202;
  time_zone \201short hours, short minutes\202;

  bool
  zone_present \201\202 const;

  void
  zone_reset \201\202;

  short
  zone_hours \201\202 const;

  void
  zone_hours \201short\202;

  short
  zone_minutes \201\202 const;

  void
  zone_minutes \201short\202;
};

bool
operator== \201const time_zone&, const time_zone&\202;

bool
operator!= \201const time_zone&, const time_zone&\202;)RP(

  )0 P(The )SM(zone_present\201\202)ES( acces)HY(sor)YH( func)HY(tion)YH( returns )SM(true)ES(
     if the time zone is spec)HY(i)HY(fied)YH(. The )SM(zone_reset\201\202)ES( modi)HY(fier)YH(
     func)HY(tion)YH( resets the time zone object to the )EM(not spec)HY(i)HY(fied)YH()ES(
     state. If the time zone offset is nega)HY(tive)YH( then both hours and
     minutes compo)HY(nents)YH( are repre)HY(sented)YH( as nega)HY(tive)YH( inte)HY(gers)YH(.)EP(


  )0 2 26 H(2.5.8)WB 123 Sn()WB 30 Sn( Mapping for )SM(date)ES()EA()EH(

 )0 P(The XML Schema )SM(date)ES( built-in data type is mapped to the
    )SM(xml_schema::date)ES( C++ class which repre)HY(sents)YH( a year, a day,
    and a month with an optional time zone. Its inter)HY(face)YH( is presented
    below. For more infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES(
    class refer to )0 29 1 A(Section 2.5.7, "Time Zone
    Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 41 60 PR(class date: public simple_type, public time_zone
{
public:
  date \201int year, unsigned short month, unsigned short day\202;
  date \201int year, unsigned short month, unsigned short day,
        short zone_hours, short zone_minutes\202;

public:
  date \201const date&\202;

  date&
  operator= \201const date&\202;

  virtual date*
  _clone \201\202 const;

public:
  int
  year \201\202 const;

  void
  year \201int\202;

  unsigned short
  month \201\202 const;

  void
  month \201unsigned short\202;

  unsigned short
  day \201\202 const;)WR(

  void
  day \201unsigned short\202;
};

bool
operator== \201const date&, const date&\202;

bool
operator!= \201const date&, const date&\202;)RP(

  )0 2 27 H(2.5.9)WB 124 Sn()WB 31 Sn( Mapping for )SM(date)HY(Time)YH()ES()EA()EH(

 )0 P(The XML Schema )SM(date)HY(Time)YH()ES( built-in data type is mapped to the
    )SM(xml_schema::date_time)ES( C++ class which repre)HY(sents)YH( a year, a month,
    a day, hours, minutes, and seconds with an optional time zone. Its inter)HY(face)YH(
    is presented below. For more infor)HY(ma)HY(tion)YH( on the base
    )SM(xml_schema::time_zone)ES( class refer to )0 29 1 A(Section
    2.5.7, "Time Zone Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 62 67 PR(class date_time: public simple_type, public time_zone
{
public:
  date_time \201int year, unsigned short month, unsigned short day,
             unsigned short hours, unsigned short minutes,
             double seconds\202;

  date_time \201int year, unsigned short month, unsigned short day,
             unsigned short hours, unsigned short minutes,
             double seconds, short zone_hours, short zone_minutes\202;
public:
  date_time \201const date_time&\202;

  date_time&
  operator= \201const date_time&\202;

  virtual date_time*
  _clone \201\202 const;

public:
  int
  year \201\202 const;

  void
  year \201int\202;

  unsigned short
  month \201\202 const;

  void
  month \201unsigned short\202;)WR(

  unsigned short
  day \201\202 const;

  void
  day \201unsigned short\202;

  unsigned short
  hours \201\202 const;

  void
  hours \201unsigned short\202;

  unsigned short
  minutes \201\202 const;

  void
  minutes \201unsigned short\202;

  double
  seconds \201\202 const;

  void
  seconds \201double\202;
};

bool
operator== \201const date_time&, const date_time&\202;

bool)WR(
operator!= \201const date_time&, const date_time&\202;)RP(


  )0 2 28 H(2.5.10)WB 125 Sn()WB 32 Sn( Mapping for )SM(dura)HY(tion)YH()ES()EA()EH(

  )0 P(The XML Schema )SM(dura)HY(tion)YH()ES( built-in data type is mapped to the
    )SM(xml_schema::dura)HY(tion)YH()ES( C++ class which repre)HY(sents)YH( a poten)HY(tially)YH(
     nega)HY(tive)YH( dura)HY(tion)YH( in the form of years, months, days, hours, minutes,
     and seconds. Its inter)HY(face)YH( is presented below.)EP(

  ) 64 71 PR(class duration: public simple_type
{
public:
  duration \201bool negative,
            unsigned int years, unsigned int months, unsigned int days,
            unsigned int hours, unsigned int minutes, double seconds\202;
public:
  duration \201const duration&\202;

  duration&
  operator= \201const duration&\202;

  virtual duration*
  _clone \201\202 const;

public:
  bool
  negative \201\202 const;

  void
  negative \201bool\202;

  unsigned int
  years \201\202 const;

  void
  years \201unsigned int\202;

  unsigned int
  months \201\202 const;
)WR(
  void
  months \201unsigned int\202;

  unsigned int
  days \201\202 const;

  void
  days \201unsigned int\202;

  unsigned int
  hours \201\202 const;

  void
  hours \201unsigned int\202;

  unsigned int
  minutes \201\202 const;

  void
  minutes \201unsigned int\202;

  double
  seconds \201\202 const;

  void
  seconds \201double\202;
};

bool
operator== \201const duration&, const duration&\202;)WR(

bool
operator!= \201const duration&, const duration&\202;)RP(


  )0 2 29 H(2.5.11)WB 126 Sn()WB 33 Sn( Mapping for )SM(gDay)ES()EA()EH(

  )0 P(The XML Schema )SM(gDay)ES( built-in data type is mapped to the
    )SM(xml_schema::gday)ES( C++ class which repre)HY(sents)YH( a day of the
     month with an optional time zone. Its inter)HY(face)YH( is presented below.
     For more infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES(
     class refer to )0 29 1 A(Section 2.5.7, "Time Zone
     Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 29 66 PR(class gday: public simple_type, public time_zone
{
public:
  explicit
  gday \201unsigned short day\202;
  gday \201unsigned short day, short zone_hours, short zone_minutes\202;

public:
  gday \201const gday&\202;

  gday&
  operator= \201const gday&\202;

  virtual gday*
  _clone \201\202 const;

public:
  unsigned short
  day \201\202 const;

  void
  day \201unsigned short\202;
};

bool
operator== \201const gday&, const gday&\202;

bool
operator!= \201const gday&, const gday&\202;)RP(


  )0 2 30 H(2.5.12)WB 127 Sn()WB 34 Sn( Mapping for )SM(gMonth)ES()EA()EH(

  )0 P(The XML Schema )SM(gMonth)ES( built-in data type is mapped to the
    )SM(xml_schema::gmonth)ES( C++ class which repre)HY(sents)YH( a month of the
     year with an optional time zone. Its inter)HY(face)YH( is presented below.
     For more infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES(
     class refer to )0 29 1 A(Section 2.5.7, "Time Zone
     Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 30 50 PR(class gmonth: public simple_type, public time_zone
{
public:
  explicit
  gmonth \201unsigned short month\202;
  gmonth \201unsigned short month,
          short zone_hours, short zone_minutes\202;

public:
  gmonth \201const gmonth&\202;

  gmonth&
  operator= \201const gmonth&\202;

  virtual gmonth*
  _clone \201\202 const;

public:
  unsigned short
  month \201\202 const;

  void
  month \201unsigned short\202;
};

bool
operator== \201const gmonth&, const gmonth&\202;

bool
operator!= \201const gmonth&, const gmonth&\202;)RP(


  )0 2 31 H(2.5.13)WB 128 Sn()WB 35 Sn( Mapping for )SM(gMon)HY(th)HY(Day)YH()ES()EA()EH(

  )0 P(The XML Schema )SM(gMon)HY(th)HY(Day)YH()ES( built-in data type is mapped to the
    )SM(xml_schema::gmonth_day)ES( C++ class which repre)HY(sents)YH( a day and
     a month of the year with an optional time zone. Its inter)HY(face)YH( is presented
     below. For more infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES(
     class refer to )0 29 1 A(Section 2.5.7, "Time Zone
     Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 35 56 PR(class gmonth_day: public simple_type, public time_zone
{
public:
  gmonth_day \201unsigned short month, unsigned short day\202;
  gmonth_day \201unsigned short month, unsigned short day,
              short zone_hours, short zone_minutes\202;

public:
  gmonth_day \201const gmonth_day&\202;

  gmonth_day&
  operator= \201const gmonth_day&\202;

  virtual gmonth_day*
  _clone \201\202 const;

public:
  unsigned short
  month \201\202 const;

  void
  month \201unsigned short\202;

  unsigned short
  day \201\202 const;

  void
  day \201unsigned short\202;
};

bool)WR(
operator== \201const gmonth_day&, const gmonth_day&\202;

bool
operator!= \201const gmonth_day&, const gmonth_day&\202;)RP(


  )0 2 32 H(2.5.14)WB 129 Sn()WB 36 Sn( Mapping for )SM(gYear)ES()EA()EH(

  )0 P(The XML Schema )SM(gYear)ES( built-in data type is mapped to the
    )SM(xml_schema::gyear)ES( C++ class which repre)HY(sents)YH( a year with
     an optional time zone. Its inter)HY(face)YH( is presented below. For more
     infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES( class refer
     to )0 29 1 A(Section 2.5.7, "Time Zone Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 29 57 PR(class gyear: public simple_type, public time_zone
{
public:
  explicit
  gyear \201int year\202;
  gyear \201int year, short zone_hours, short zone_minutes\202;

public:
  gyear \201const gyear&\202;

  gyear&
  operator= \201const gyear&\202;

  virtual gyear*
  _clone \201\202 const;

public:
  int
  year \201\202 const;

  void
  year \201int\202;
};

bool
operator== \201const gyear&, const gyear&\202;

bool
operator!= \201const gyear&, const gyear&\202;)RP(


  )0 2 33 H(2.5.15)WB 130 Sn()WB 37 Sn( Mapping for )SM(gYear)HY(Month)YH()ES()EA()EH(

  )0 P(The XML Schema )SM(gYear)HY(Month)YH()ES( built-in data type is mapped to
     the )SM(xml_schema::gyear_month)ES( C++ class which repre)HY(sents)YH(
     a year and a month with an optional time zone. Its inter)HY(face)YH( is presented
     below. For more infor)HY(ma)HY(tion)YH( on the base )SM(xml_schema::time_zone)ES(
     class refer to )0 29 1 A(Section 2.5.7, "Time Zone
     Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 34 55 PR(class gyear_month: public simple_type, public time_zone
{
public:
  gyear_month \201int year, unsigned short month\202;
  gyear_month \201int year, unsigned short month,
               short zone_hours, short zone_minutes\202;
public:
  gyear_month \201const gyear_month&\202;

  gyear_month&
  operator= \201const gyear_month&\202;

  virtual gyear_month*
  _clone \201\202 const;

public:
  int
  year \201\202 const;

  void
  year \201int\202;

  unsigned short
  month \201\202 const;

  void
  month \201unsigned short\202;
};

bool
operator== \201const gyear_month&, const gyear_month&\202;)WR(

bool
operator!= \201const gyear_month&, const gyear_month&\202;)RP(


  )0 2 34 H(2.5.16)WB 131 Sn()WB 38 Sn( Mapping for )SM(time)ES()EA()EH(

  )0 P(The XML Schema )SM(time)ES( built-in data type is mapped to
     the )SM(xml_schema::time)ES( C++ class which repre)HY(sents)YH( hours,
     minutes, and seconds with an optional time zone. Its inter)HY(face)YH( is
     presented below. For more infor)HY(ma)HY(tion)YH( on the base
     )SM(xml_schema::time_zone)ES( class refer to
     )0 29 1 A(Section 2.5.7, "Time Zone Repre)HY(sen)HY(ta)HY(tion)YH(")29 0 TN TL()Ec /AF f D(.)EP(

  ) 41 70 PR(class time: public simple_type, public time_zone
{
public:
  time \201unsigned short hours, unsigned short minutes, double seconds\202;
  time \201unsigned short hours, unsigned short minutes, double seconds,
        short zone_hours, short zone_minutes\202;

public:
  time \201const time&\202;

  time&
  operator= \201const time&\202;

  virtual time*
  _clone \201\202 const;

public:
  unsigned short
  hours \201\202 const;

  void
  hours \201unsigned short\202;

  unsigned short
  minutes \201\202 const;

  void
  minutes \201unsigned short\202;

  double
  seconds \201\202 const;)WR(

  void
  seconds \201double\202;
};

bool
operator== \201const time&, const time&\202;

bool
operator!= \201const time&, const time&\202;)RP(


  

  )0 2 35 H(2.6)WB 132 Sn()WB 39 Sn( Mapping for Simple Types)EA()EH(

  )0 P(An XML Schema simple type is mapped to a C++ class with the same
     name as the simple type. The class defines a public copy construc)HY(tor)YH(,
     a public copy assign)HY(ment)YH( oper)HY(a)HY(tor)YH(, and a public virtual
     )SM(_clone)ES( func)HY(tion)YH(. The )SM(_clone)ES( func)HY(tion)YH( is
     declared )SM(const)ES(, does not take any argu)HY(ments)YH(, and returns
     a pointer to a complete copy of the instance allo)HY(cated)YH( in the free
     store. The )SM(_clone)ES( func)HY(tion)YH( shall be used to make copies
     when static type and dynamic type of the instance may differ \201see
     )0 56 1 A(Section 2.11, "Mapping for )SM(xsi:type)ES(
     and Substi)HY(tu)HY(tion)YH( Groups")56 0 TN TL()Ec /AF f D(\202. For instance:)EP(

  ) 3 26 PR(<simpleType name="object">
  ...
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 16 28 PR(class object: ...
{
public:
  object \201const object&\202;

public:
  object&
  operator= \201const object&\202;

public:
  virtual object*
  _clone \201\202 const;

  ...

};)RP(

  )0 P(The base class spec)HY(i)HY(fi)HY(ca)HY(tion)YH( and the rest of the class defi)HY(ni)HY(tion)YH(
     depend on the type of deriva)HY(tion)YH( used to define the simple type. )EP(


  )0 3 36 H(2.6.1)WB 133 Sn()WB 40 Sn( Mapping for Deriva)HY(tion)YH( by Restric)HY(tion)YH()EA()EH(

  )0 P(XML Schema deriva)HY(tion)YH( by restric)HY(tion)YH( is mapped to C++ public
     inher)HY(i)HY(tance)YH(. The base type of the restric)HY(tion)YH( becomes the base
     type for the result)HY(ing)YH( C++ class. In addi)HY(tion)YH( to the members described
     in )0 39 1 A(Section 2.6, "Mapping for Simple Types")39 0 TN TL()Ec /AF f D(, the
     result)HY(ing)YH( C++ class defines a public construc)HY(tor)YH( with the base type
     as its single argu)HY(ment)YH(. For instance:)EP(

  ) 5 27 PR(<simpleType name="object">
  <restriction base="base">
    ...
  </restriction>
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 14 28 PR(class object: public base
{
public:
  object \201const base&\202;
  object \201const object&\202;

public:
  object&
  operator= \201const object&\202;

public:
  virtual object*
  _clone \201\202 const;
};)RP(


  )0 3 37 H(2.6.2)WB 134 Sn()WB 41 Sn( Mapping for Enumer)HY(a)HY(tions)YH()EA()EH(

)0 P(XML Schema restric)HY(tion)YH( by enumer)HY(a)HY(tion)YH( is mapped to a C++ class
   with seman)HY(tics)YH( similar to C++ )SM(enum)ES(. Each XML Schema
   enumer)HY(a)HY(tion)YH( element is mapped to a C++ enumer)HY(a)HY(tor)YH( with the
   name derived from the )SM(value)ES( attribute and defined
   in the class scope. In addi)HY(tion)YH( to the members
   described in )0 39 1 A(Section 2.6, "Mapping for Simple Types")39 0 TN TL()Ec /AF f D(,
   the result)HY(ing)YH( C++ class defines a public construc)HY(tor)YH( that can be called
   with one of the enumer)HY(a)HY(tors)YH( as its single argu)HY(ment)YH(, a public construc)HY(tor)YH(
   that can be called with enumer)HY(a)HY(tion)YH('s base value as its single
   argu)HY(ment)YH(, a public assign)HY(ment)YH( oper)HY(a)HY(tor)YH( that can be used to assign the
   value of one of the enumer)HY(a)HY(tors)YH(, and a public implicit conver)HY(sion)YH(
   oper)HY(a)HY(tor)YH( to the under)HY(ly)HY(ing)YH( C++ enum type.)EP(

)0 P(Further)HY(more)YH(, for string-based enumer)HY(a)HY(tion)YH( types, the result)HY(ing)YH( C++
   class defines a public construc)HY(tor)YH( with a single argu)HY(ment)YH( of type
   )SM(const C*)ES( and a public construc)HY(tor)YH( with a single
   argu)HY(ment)YH( of type )SM(const std::basic_string<C>&)ES(.
   For instance:)EP(

  ) 7 32 PR(<simpleType name="color">
  <restriction base="string">
    <enumeration value="red"/>
    <enumeration value="green"/>
    <enumeration value="blue"/>
  </restriction>
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 31 38 PR(class color: public xml_schema::string
{
public:
  enum value
  {
    red,
    green,
    blue
  };

public:
  color \201value\202;
  color \201const C*\202;
  color \201const std::basic_string<C>&\202;
  color \201const xml_schema::string&\202;
  color \201const color&\202;

public:
  color&
  operator= \201value\202;

  color&
  operator= \201const color&\202;

public:
  virtual color*
  _clone \201\202 const;

public:
  operator value \201\202 const;
};)WR()RP(

  )0 3 38 H(2.6.3)WB 135 Sn()WB 42 Sn( Mapping for Deriva)HY(tion)YH( by List)EA()EH(

  )0 P(XML Schema deriva)HY(tion)YH( by list is mapped to C++ public
     inher)HY(i)HY(tance)YH( from )SM(xml_schema::simple_type)ES(
     \201)0 25 1 A(Section 2.5.3, "Mapping for
     )SM(anySim)HY(ple)HY(Type)YH()ES(")25 0 TN TL()Ec /AF f D(\202 and a suit)HY(able)YH( sequence type.
     The list item type becomes the element type of the sequence.
     In addi)HY(tion)YH( to the members described in )0 39 1 A(Section 2.6,
     "Mapping for Simple Types")39 0 TN TL()Ec /AF f D(, the result)HY(ing)YH( C++ class defines
     a public default construc)HY(tor)YH(, a public construc)HY(tor)YH(
     with the first argu)HY(ment)YH( of type )SM(size_type)ES( and
     the second argu)HY(ment)YH( of list item type that creates
     a list object with the spec)HY(i)HY(fied)YH( number of copies of the spec)HY(i)HY(fied)YH(
     element value, and a public construc)HY(tor)YH( with the two argu)HY(ments)YH(
     of an input iter)HY(a)HY(tor)YH( type that creates a list object from an
     iter)HY(a)HY(tor)YH( range. For instance:
  )EP(

  ) 3 28 PR(<simpleType name="int_list">
  <list itemType="int"/>
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 19 42 PR(class int_list: public simple_type,
                public sequence<int>
{
public:
  int_list \201\202;
  int_list \201size_type n, int x\202;

  template <typename I>
  int_list \201const I& begin, const I& end\202;
  int_list \201const int_list&\202;

public:
  int_list&
  operator= \201const int_list&\202;

public:
  virtual int_list*
  _clone \201\202 const;
};)RP(

  )0 P(The )SM(sequence)ES( class template is defined in an
     imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH(. It conforms to the
     sequence inter)HY(face)YH( as defined by the ISO/ANSI Stan)HY(dard)YH( for
     C++ \201ISO/IEC 14882:1998, Section 23.1.1, "Sequences"\202.
     Prac)HY(ti)HY(cally)YH(, this means that you can treat such a sequence
     as if it was )SM(std::vector)ES(. One notable exten)HY(sion)YH(
     to the stan)HY(dard)YH( inter)HY(face)YH( that is avail)HY(able)YH( only for
     sequences of non-funda)HY(men)HY(tal)YH( C++ types is the addi)HY(tion)YH( of
     the over)HY(loaded)YH( )SM(push_back)ES( and )SM(insert)ES(
     member func)HY(tions)YH( which instead of the constant refer)HY(ence)YH(
     to the element type accept auto)HY(matic)YH( pointer \201)SM(std::auto_ptr)ES(
     or )SM(std::unique_ptr)ES(, depend)HY(ing)YH( on the C++ stan)HY(dard)YH(
     selected\202 to the element type. These func)HY(tions)YH( assume owner)HY(ship)YH(
     of the pointed to object and reset the passed auto)HY(matic)YH( pointer.
  )EP(

  )0 3 39 H(2.6.4)WB 136 Sn()WB 43 Sn( Mapping for Deriva)HY(tion)YH( by Union)EA()EH(

  )0 P(XML Schema deriva)HY(tion)YH( by union is mapped to C++ public
     inher)HY(i)HY(tance)YH( from )SM(xml_schema::simple_type)ES(
     \201)0 25 1 A(Section 2.5.3, "Mapping for
     )SM(anySim)HY(ple)HY(Type)YH()ES(")25 0 TN TL()Ec /AF f D(\202 and )SM(std::basic_string<C>)ES(.
     In addi)HY(tion)YH( to the members described in )0 39 1 A(Section 2.6,
     "Mapping for Simple Types")39 0 TN TL()Ec /AF f D(, the result)HY(ing)YH( C++ class defines a
     public construc)HY(tor)YH( with a single argu)HY(ment)YH( of type )SM(const C*)ES(
     and a public construc)HY(tor)YH( with a single argu)HY(ment)YH( of type
     )SM(const std::basic_string<C>&)ES(. For instance:
  )EP(

  ) 3 47 PR(<simpleType name="int_string_union">
  <xsd:union memberTypes="xsd:int xsd:string"/>
</simpleType>)RP(

  )0 P(is mapped to:)EP(

  ) 16 51 PR(class int_string_union: public simple_type,
                        public std::basic_string<C>
{
public:
  int_string_union \201const C*\202;
  int_string_union \201const std::basic_string<C>&\202;
  int_string_union \201const int_string_union&\202;

public:
  int_string_union&
  operator= \201const int_string_union&\202;

public:
  virtual int_string_union*
  _clone \201\202 const;
};)RP(

  )0 2 40 H(2.7)WB 137 Sn()WB 44 Sn( Mapping for Complex Types)EA()EH(

  )0 P(An XML Schema complex type is mapped to a C++ class with the same
     name as the complex type. The class defines a public copy construc)HY(tor)YH(,
     a public copy assign)HY(ment)YH( oper)HY(a)HY(tor)YH(, and a public virtual
     )SM(_clone)ES( func)HY(tion)YH(. The )SM(_clone)ES( func)HY(tion)YH( is
     declared )SM(const)ES(, does not take any argu)HY(ments)YH(, and returns
     a pointer to a complete copy of the instance allo)HY(cated)YH( in the free
     store. The )SM(_clone)ES( func)HY(tion)YH( shall be used to make copies
     when static type and dynamic type of the instance may differ \201see
     )0 56 1 A(Section 2.11, "Mapping for )SM(xsi:type)ES(
     and Substi)HY(tu)HY(tion)YH( Groups")56 0 TN TL()Ec /AF f D(\202.)EP(

  )0 P(Addi)HY(tion)HY(ally)YH(, the result)HY(ing)YH( C++ class
     defines two public construc)HY(tors)YH( that take an initial)HY(izer)YH( for each
     member of the complex type and all its base types that belongs to
     the One cardi)HY(nal)HY(ity)YH( class \201see )0 47 1 A(Section 2.8, "Mapping
     for Local Elements and Attributes")47 0 TN TL()Ec /AF f D(\202. In the first construc)HY(tor)YH(,
     the argu)HY(ments)YH( are passed as constant refer)HY(ences)YH( and the newly created
     instance is initial)HY(ized)YH( with copies of the passed objects. In the
     second construc)HY(tor)YH(, argu)HY(ments)YH( that are complex types \201that is,
     they them)HY(selves)YH( contain elements or attributes\202 are passed as
     either )SM(std::auto_ptr)ES( \201C++98\202 or )SM(std::unique_ptr)ES(
     \201C++11\202, depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected. In this case the newly
     created instance is directly initial)HY(ized)YH( with and assumes owner)HY(ship)YH(
     of the pointed to objects and the )SM(std::[auto|unique]_ptr)ES(
     argu)HY(ments)YH( are reset to )SM(0)ES(. For instance:)EP(

  ) 15 66 PR(<complexType name="complex">
  <sequence>
    <element name="a" type="int"/>
    <element name="b" type="string"/>
  </sequence>
</complexType>

<complexType name="object">
  <sequence>
    <element name="s-one" type="boolean"/>
    <element name="c-one" type="complex"/>
    <element name="optional" type="int" minOccurs="0"/>
    <element name="sequence" type="string" maxOccurs="unbounded"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 36 68 PR(class complex: public xml_schema::type
{
public:
  object \201const int& a, const xml_schema::string& b\202;
  object \201const complex&\202;

public:
  object&
  operator= \201const complex&\202;

public:
  virtual complex*
  _clone \201\202 const;

  ...

};

class object: public xml_schema::type
{
public:
  object \201const bool& s_one, const complex& c_one\202;
  object \201const bool& s_one, std::[auto|unique]_ptr<complex> c_one\202;
  object \201const object&\202;

public:
  object&
  operator= \201const object&\202;

public:
  virtual object*)WR(
  _clone \201\202 const;

  ...

};)RP(

  )0 P(Notice that the gener)HY(ated)YH( )SM(complex)ES( class does not
     have the second \201)SM(std::[auto|unique]_ptr)ES(\202 version of the
     construc)HY(tor)YH( since all its required members are of simple types.)EP(

  )0 P(If an XML Schema complex type has an ulti)HY(mate)YH( base which is an XML
     Schema simple type then the result)HY(ing)YH( C++ class also defines a public
     construc)HY(tor)YH( that takes an initial)HY(izer)YH( for the base type as well as
     for each member of the complex type and all its base types that
     belongs to the One cardi)HY(nal)HY(ity)YH( class. For instance:)EP(

  ) 7 61 PR(<complexType name="object">
  <simpleContent>
    <extension base="date">
      <attribute name="lang" type="language" use="required"/>
    </extension>
  </simpleContent>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 11 44 PR(class object: public xml_schema::string
{
public:
  object \201const xml_schema::language& lang\202;

  object \201const xml_schema::date& base,
          const xml_schema::language& lang\202;

  ...

};)RP(

  )0 P(Further)HY(more)YH(, for string-based XML Schema complex types, the result)HY(ing)YH( C++
     class also defines two  public construc)HY(tors)YH( with the first argu)HY(ments)YH(
     of type )SM(const C*)ES( and )SM(std::basic_string<C>&)ES(,
     respec)HY(tively)YH(, followed by argu)HY(ments)YH( for each member of the complex
     type and all its base types that belongs to the One cardi)HY(nal)HY(ity)YH(
     class. For enumer)HY(a)HY(tion)YH(-based complex types the result)HY(ing)YH( C++
     class also defines a public construc)HY(tor)YH( with the first argu)HY(ments)YH(
     of the under)HY(ly)HY(ing)YH( enum type followed by argu)HY(ments)YH( for each member
     of the complex type and all its base types that belongs to the One
     cardi)HY(nal)HY(ity)YH( class. For instance:)EP(

  ) 15 61 PR(<simpleType name="color">
  <restriction base="string">
    <enumeration value="red"/>
    <enumeration value="green"/>
    <enumeration value="blue"/>
  </restriction>
</simpleType>

<complexType name="object">
  <simpleContent>
    <extension base="color">
      <attribute name="lang" type="language" use="required"/>
    </extension>
  </simpleContent>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 37 44 PR(class color: public xml_schema::string
{
public:
  enum value
  {
    red,
    green,
    blue
  };

public:
  color \201value\202;
  color \201const C*\202;
  color \201const std::basic_string<C>&\202;

  ...

};

class object: color
{
public:
  object \201const color& base,
          const xml_schema::language& lang\202;

  object \201const color::value& base,
          const xml_schema::language& lang\202;

  object \201const C* base,
          const xml_schema::language& lang\202;
)WR(
  object \201const std::basic_string<C>& base,
          const xml_schema::language& lang\202;

  ...

};)RP(

  )0 P(Addi)HY(tional)YH( construc)HY(tors)YH( can be requested with the
     )SM(--gener)HY(ate)YH(-default-ctor)ES( and
     )SM(--gener)HY(ate)YH(-from-base-ctor)ES( options. See the
     )R8 2 A(XSD
     Compiler Command Line Manual)EA( for details.)EP(

  )0 P(If an XML Schema complex type is not explic)HY(itly)YH( derived from any type,
     the result)HY(ing)YH( C++ class is derived from )SM(xml_schema::type)ES(.
     In cases where an XML Schema complex type is defined using deriva)HY(tion)YH(
     by exten)HY(sion)YH( or restric)HY(tion)YH(, the result)HY(ing)YH( C++ base class spec)HY(i)HY(fi)HY(ca)HY(tion)YH(
     depends on the type of deriva)HY(tion)YH( and is described in the subse)HY(quent)YH(
     sections.
  )EP(

  )0 P(The mapping for elements and attributes that are defined in a complex
     type is described in )0 47 1 A(Section 2.8, "Mapping for Local
     Elements and Attributes")47 0 TN TL()Ec /AF f D(.
  )EP(

  )0 3 41 H(2.7.1)WB 138 Sn()WB 45 Sn( Mapping for Deriva)HY(tion)YH( by Exten)HY(sion)YH()EA()EH(

  )0 P(XML Schema deriva)HY(tion)YH( by exten)HY(sion)YH( is mapped to C++ public
     inher)HY(i)HY(tance)YH(. The base type of the exten)HY(sion)YH( becomes the base
     type for the result)HY(ing)YH( C++ class.
  )EP(

  )0 3 42 H(2.7.2)WB 139 Sn()WB 46 Sn( Mapping for Deriva)HY(tion)YH( by Restric)HY(tion)YH()EA()EH(

  )0 P(XML Schema deriva)HY(tion)YH( by restric)HY(tion)YH( is mapped to C++ public
     inher)HY(i)HY(tance)YH(. The base type of the restric)HY(tion)YH( becomes the base
     type for the result)HY(ing)YH( C++ class. XML Schema elements and
     attributes defined within restric)HY(tion)YH( do not result in any
     defi)HY(ni)HY(tions)YH( in the result)HY(ing)YH( C++ class. Instead, corre)HY(spond)HY(ing)YH(
     \201unre)HY(stricted)YH(\202 defi)HY(ni)HY(tions)YH( are inher)HY(ited)YH( from the base class.
     In the future versions of this mapping, such elements and
     attributes may result in redef)HY(i)HY(ni)HY(tions)YH( of acces)HY(sors)YH( and
     modi)HY(fiers)YH( to reflect their restricted seman)HY(tics)YH(.
  )EP(

  

  )0 2 43 H(2.8)WB 140 Sn()WB 47 Sn( Mapping for Local Elements and Attributes)EA()EH(

   )0 P(XML Schema element and attribute defi)HY(ni)HY(tions)YH( are called local
      if they appear within a complex type defi)HY(ni)HY(tion)YH(, an element group
      defi)HY(ni)HY(tion)YH(, or an attribute group defi)HY(ni)HY(tions)YH(.
   )EP(

   )0 P(Local XML Schema element and attribute defi)HY(ni)HY(tions)YH( have the same
      C++ mapping. There)HY(fore)YH(, in this section, local elements and
      attributes are collec)HY(tively)YH( called members.
   )EP(

   )0 P(While there are many differ)HY(ent)YH( member cardi)HY(nal)HY(ity)YH( combi)HY(na)HY(tions)YH(
      \201deter)HY(mined)YH( by the )SM(use)ES( attribute for attributes and
       the )SM(minOc)HY(curs)YH()ES( and )SM(maxOc)HY(curs)YH()ES( attributes
       for elements\202, the mapping divides all possi)HY(ble)YH( cardi)HY(nal)HY(ity)YH(
       combi)HY(na)HY(tions)YH( into three cardi)HY(nal)HY(ity)YH( classes:
   )EP(

   )0 DL(     )0 DT()I(one)ES(
     )DD(attributes: )SM(use == "required")ES(
     )DD(attributes: )SM(use == "optional")ES( and has default or fixed value
     )DD(elements: )SM(minOc)HY(curs)YH( == "1")ES( and )SM(maxOc)HY(curs)YH( == "1")ES(

     )0 DT()I(optional)ES(
     )DD(attributes: )SM(use == "optional")ES( and doesn't have default or fixed value
     )DD(elements: )SM(minOc)HY(curs)YH( == "0")ES( and )SM(maxOc)HY(curs)YH( == "1")ES(

     )0 DT()I(sequence)ES(
     )DD(elements: )SM(maxOc)HY(curs)YH( > "1")ES(
   )LD(

   )0 P(An optional attribute with a default or fixed value acquires this value
      if the attribute hasn't been spec)HY(i)HY(fied)YH( in an instance docu)HY(ment)YH( \201see
      )0 95 1 A(Appendix A, "Default and Fixed Values")95 0 TN TL()Ec /AF f D(\202. This
      mapping places such optional attributes to the One cardi)HY(nal)HY(ity)YH(
      class.)EP(

   )0 P(A member is mapped to a set of public type defi)HY(ni)HY(tions)YH(
      \201)SM(typedef)ES(s\202 and a set of public acces)HY(sor)YH( and modi)HY(fier)YH(
      func)HY(tions)YH(. Type defi)HY(ni)HY(tions)YH( have names derived from the member's
      name. The acces)HY(sor)YH( and modi)HY(fier)YH( func)HY(tions)YH( have the same name as the
      member. For example:
   )EP(

  ) 5 42 PR(<complexType name="object">
  <sequence>
    <element name="member" type="string"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 11 41 PR(class object: public xml_schema::type
{
public:
  typedef xml_schema::string member_type;

  const member_type&
  member \201\202 const;

  ...

};)RP(

   )0 P(In addi)HY(tion)YH(, if a member has a default or fixed value, a static
      acces)HY(sor)YH( func)HY(tion)YH( is gener)HY(ated)YH( that returns this value. For
      example:)EP(

) 3 55 PR(<complexType name="object">
  <attribute name="data" type="string" default="test"/>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 14 39 PR(class object: public xml_schema::type
{
public:
  typedef xml_schema::string data_type;

  const data_type&
  data \201\202 const;

  static const data_type&
  data_default_value \201\202;

  ...

};)RP(

   )0 P(Names and seman)HY(tics)YH( of type defi)HY(ni)HY(tions)YH( for the member as well
      as signa)HY(tures)YH( of the acces)HY(sor)YH( and modi)HY(fier)YH( func)HY(tions)YH( depend on
      the member's cardi)HY(nal)HY(ity)YH( class and are described in the follow)HY(ing)YH(
      sub-sections.
   )EP(


  )0 3 44 H(2.8.1)WB 141 Sn()WB 48 Sn( Mapping for Members with the One Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

   )0 P(For the One cardi)HY(nal)HY(ity)YH( class, the type defi)HY(ni)HY(tions)YH( consist of
      an alias for the member's type with the name created by append)HY(ing)YH(
      the )SM(_type)ES( suffix to the member's name.
   )EP(

   )0 P(The acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
      The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to the
      member and can be used for read-only access. The non-constant
      version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the member and can
      be used for read-write access.
   )EP(

   )0 P(The first modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to
      constant of the member's type. It makes a deep copy of its argu)HY(ment)YH(.
      Except for member's types that are mapped to funda)HY(men)HY(tal)YH( C++ types,
      the second modi)HY(fier)YH( func)HY(tion)YH( is provided that expects an argu)HY(ment)YH(
      of type auto)HY(matic)YH( pointer \201)SM(std::auto_ptr)ES( or
      )SM(std::unique_ptr)ES(, depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected\202
      to the member's type. It assumes owner)HY(ship)YH( of the pointed to object
      and resets the passed auto)HY(matic)YH( pointer. For instance:)EP(

  ) 5 42 PR(<complexType name="object">
  <sequence>
    <element name="member" type="string"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 25 47 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef xml_schema::string member_type;

  // Accessors.
  //
  const member_type&
  member \201\202 const;

  member_type&
  member \201\202;

  // Modifiers.
  //
  void
  member \201const member_type&\202;

  void
  member \201std::[auto|unique]_ptr<member_type>\202;
  ...

};)RP(

   )0 P(In addi)HY(tion)YH(, if requested by spec)HY(i)HY(fy)HY(ing)YH( the )SM(--gener)HY(ate)YH(-detach)ES(
      option and only for members of non-funda)HY(men)HY(tal)YH( C++ types, the mapping
      provides a detach func)HY(tion)YH( that returns an auto)HY(matic)YH( pointer to the
      member's type, for example:)EP(

  ) 10 37 PR(class object: public xml_schema::type
{
public:
  ...

  std::[auto|unique]_ptr<member_type>
  detach_member \201\202;
  ...

};)RP(

   )0 P(This func)HY(tion)YH( detaches the value from the tree leaving the member
      value unini)HY(tial)HY(ized)YH(. Access)HY(ing)YH( such an unini)HY(tial)HY(ized)YH( value prior to
      re-initial)HY(iz)HY(ing)YH( it results in unde)HY(fined)YH( behav)HY(ior)YH(.)EP(

  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 25 66 PR(void
f \201object& o\202
{
  using xml_schema::string;

  string s \201o.member \201\202\202;                // get
  object::member_type& sr \201o.member \201\202\202; // get

  o.member \201"hello"\202;           // set, deep copy
  o.member \201\202 = "hello";        // set, deep copy

  // C++98 version.
  //
  std::auto_ptr<string> p \201new string \201"hello"\202\202;
  o.member \201p\202;                 // set, assumes ownership
  p = o.detach_member \201\202;       // detach, member is uninitialized
  o.member \201p\202;                 // re-attach

  // C++11 version.
  //
  std::unique_ptr<string> p \201new string \201"hello"\202\202;
  o.member \201std::move \201p\202\202;     // set, assumes ownership
  p = o.detach_member \201\202;       // detach, member is uninitialized
  o.member \201std::move \201p\202\202;     // re-attach
})RP(


)0 3 45 H(2.8.2)WB 142 Sn()WB 49 Sn( Mapping for Members with the Optional Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

   )0 P(For the Optional cardi)HY(nal)HY(ity)YH( class, the type defi)HY(ni)HY(tions)YH( consist of
      an alias for the member's type with the name created by append)HY(ing)YH(
      the )SM(_type)ES( suffix to the member's name and an alias for
      the container type with the name created by append)HY(ing)YH( the
      )SM(_optional)ES( suffix to the member's name.
   )EP(

   )0 P(Unlike acces)HY(sor)YH( func)HY(tions)YH( for the One cardi)HY(nal)HY(ity)YH( class, acces)HY(sor)YH(
      func)HY(tions)YH( for the Optional cardi)HY(nal)HY(ity)YH( class return refer)HY(ences)YH( to
      corre)HY(spond)HY(ing)YH( contain)HY(ers)YH( rather than directly to members. The
      acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
      The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to
      the container and can be used for read-only access. The non-constant
      version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the container
      and can be used for read-write access.
   )EP(

   )0 P(The modi)HY(fier)YH( func)HY(tions)YH( are over)HY(loaded)YH( for the member's
      type and the container type. The first modi)HY(fier)YH( func)HY(tion)YH(
      expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to constant of the
      member's type. It makes a deep copy of its argu)HY(ment)YH(.
      Except for member's types that are mapped to funda)HY(men)HY(tal)YH( C++ types,
      the second modi)HY(fier)YH( func)HY(tion)YH( is provided that expects an argu)HY(ment)YH(
      of type auto)HY(matic)YH( pointer \201)SM(std::auto_ptr)ES( or
      )SM(std::unique_ptr)ES(, depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected\202
      to the member's type. It assumes owner)HY(ship)YH( of the pointed to object
      and resets the passed auto)HY(matic)YH( pointer. The last modi)HY(fier)YH( func)HY(tion)YH(
      expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to constant of the container
      type. It makes a deep copy of its argu)HY(ment)YH(. For instance:
   )EP(

  ) 5 56 PR(<complexType name="object">
  <sequence>
    <element name="member" type="string" minOccurs="0"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 30 48 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef xml_schema::string member_type;
  typedef optional<member_type> member_optional;

  // Accessors.
  //
  const member_optional&
  member \201\202 const;

  member_optional&
  member \201\202;

  // Modifiers.
  //
  void
  member \201const member_type&\202;

  void
  member \201std::[auto|unique]_ptr<member_type>\202;

  void
  member \201const member_optional&\202;

  ...

};)RP(


  )0 P(The )SM(optional)ES( class template is defined in an
     imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH( and has the follow)HY(ing)YH(
     inter)HY(face)YH(. The )SM([auto|unique]_ptr)ES(-based construc)HY(tor)YH(
     and modi)HY(fier)YH( func)HY(tion)YH( are only avail)HY(able)YH( if the template
     argu)HY(ment)YH( is not a funda)HY(men)HY(tal)YH( C++ type.
  )EP(

  ) 97 52 PR(template <typename X>
class optional
{
public:
  optional \201\202;

  // Makes a deep copy.
  //
  explicit
  optional \201const X&\202;

  // Assumes ownership.
  //
  explicit
  optional \201std::[auto|unique]_ptr<X>\202;

  optional \201const optional&\202;

public:
  optional&
  operator= \201const X&\202;

  optional&
  operator= \201const optional&\202;

  // Pointer-like interface.
  //
public:
  const X*
  operator-> \201\202 const;
)WR(
  X*
  operator-> \201\202;

  const X&
  operator* \201\202 const;

  X&
  operator* \201\202;

  typedef void \201optional::*bool_convertible\202 \201\202;
  operator bool_convertible \201\202 const;

  // Get/set interface.
  //
public:
  bool
  present \201\202 const;

  const X&
  get \201\202 const;

  X&
  get \201\202;

  // Makes a deep copy.
  //
  void
  set \201const X&\202;

  // Assumes ownership.)WR(
  //
  void
  set \201std::[auto|unique]_ptr<X>\202;

  // Detach and return the contained value.
  //
  std::[auto|unique]_ptr<X>
  detach \201\202;

  void
  reset \201\202;
};

template <typename X>
bool
operator== \201const optional<X>&, const optional<X>&\202;

template <typename X>
bool
operator!= \201const optional<X>&, const optional<X>&\202;

template <typename X>
bool
operator< \201const optional<X>&, const optional<X>&\202;

template <typename X>
bool
operator> \201const optional<X>&, const optional<X>&\202;

template <typename X>)WR(
bool
operator<= \201const optional<X>&, const optional<X>&\202;

template <typename X>
bool
operator>= \201const optional<X>&, const optional<X>&\202;)RP(


  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 45 62 PR(void
f \201object& o\202
{
  using xml_schema::string;

  if \201o.member \201\202.present \201\202\202       // test
  {
    string& s \201o.member \201\202.get \201\202\202; // get
    o.member \201"hello"\202;             // set, deep copy
    o.member \201\202.set \201"hello"\202;      // set, deep copy
    o.member \201\202.reset \201\202;           // reset
  }

  // Same as above but using pointer notation:
  //
  if \201o.member \201\202\202                  // test
  {
    string& s \201*o.member \201\202\202;       // get
    o.member \201"hello"\202;             // set, deep copy
    *o.member \201\202 = "hello";         // set, deep copy
    o.member \201\202.reset \201\202;           // reset
  }

  // C++98 version.
  //
  std::auto_ptr<string> p \201new string \201"hello"\202\202;
  o.member \201p\202;                     // set, assumes ownership

  p = new string \201"hello"\202;
  o.member \201\202.set \201p\202;              // set, assumes ownership
)WR(
  p = o.member \201\202.detach \201\202;        // detach, member is reset
  o.member \201\202.set \201p\202;              // re-attach

  // C++11 version.
  //
  std::unique_ptr<string> p \201new string \201"hello"\202\202;
  o.member \201std::move \201p\202\202;         // set, assumes ownership

  p.reset \201new string \201"hello"\202\202;
  o.member \201\202.set \201std::move \201p\202\202;  // set, assumes ownership

  p = o.member \201\202.detach \201\202;        // detach, member is reset
  o.member \201\202.set \201std::move \201p\202\202;  // re-attach
})RP(


  )0 3 46 H(2.8.3)WB 143 Sn()WB 50 Sn( Mapping for Members with the Sequence Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

   )0 P(For the Sequence cardi)HY(nal)HY(ity)YH( class, the type defi)HY(ni)HY(tions)YH( consist of an
      alias for the member's type with the name created by append)HY(ing)YH(
      the )SM(_type)ES( suffix to the member's name, an alias of
      the container type with the name created by append)HY(ing)YH( the
      )SM(_sequence)ES( suffix to the member's name, an alias of
      the iter)HY(a)HY(tor)YH( type with the name created by append)HY(ing)YH( the
      )SM(_iter)HY(a)HY(tor)YH()ES( suffix to the member's name, and an alias
      of the constant iter)HY(a)HY(tor)YH( type with the name created by append)HY(ing)YH( the
      )SM(_const_iter)HY(a)HY(tor)YH()ES( suffix to the member's name.
   )EP(

   )0 P(The acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
      The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to the
      container and can be used for read-only access. The non-constant
      version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the container and can
      be used for read-write access.
   )EP(

   )0 P(The modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to
      constant of the container type. The modi)HY(fier)YH( func)HY(tion)YH(
      makes a deep copy of its argu)HY(ment)YH(. For instance:
   )EP(


  ) 5 64 PR(<complexType name="object">
  <sequence>
    <element name="member" type="string" minOccurs="unbounded"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 26 64 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef xml_schema::string member_type;
  typedef sequence<member_type> member_sequence;
  typedef member_sequence::iterator member_iterator;
  typedef member_sequence::const_iterator member_const_iterator;

  // Accessors.
  //
  const member_sequence&
  member \201\202 const;

  member_sequence&
  member \201\202;

  // Modifier.
  //
  void
  member \201const member_sequence&\202;

  ...

};)RP(

  )0 P(The )SM(sequence)ES( class template is defined in an
     imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH(. It conforms to the
     sequence inter)HY(face)YH( as defined by the ISO/ANSI Stan)HY(dard)YH( for
     C++ \201ISO/IEC 14882:1998, Section 23.1.1, "Sequences"\202.
     Prac)HY(ti)HY(cally)YH(, this means that you can treat such a sequence
     as if it was )SM(std::vector)ES(. Two notable exten)HY(sions)YH(
     to the stan)HY(dard)YH( inter)HY(face)YH( that are avail)HY(able)YH( only for
     sequences of non-funda)HY(men)HY(tal)YH( C++ types are the addi)HY(tion)YH( of
     the over)HY(loaded)YH( )SM(push_back)ES( and )SM(insert)ES(
     as well as the )SM(detach_back)ES( and )SM(detach)ES(
     member func)HY(tions)YH(. The addi)HY(tional)YH( )SM(push_back)ES( and
     )SM(insert)ES( func)HY(tions)YH( accept an auto)HY(matic)YH( pointer
     \201)SM(std::auto_ptr)ES( or )SM(std::unique_ptr)ES(,
     depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected\202 to the
     element type instead of the constant refer)HY(ence)YH(. They assume
     owner)HY(ship)YH( of the pointed to object and reset the passed
     auto)HY(matic)YH( pointer. The )SM(detach_back)ES( and
     )SM(detach)ES( func)HY(tions)YH( detach the element
     value from the sequence container and, by default, remove
     the element from the sequence. These addi)HY(tional)YH( func)HY(tions)YH(
     have the follow)HY(ing)YH( signa)HY(tures)YH(:)EP(

  ) 22 55 PR(template <typename X>
class sequence
{
public:
  ...

  void
  push_back \201std::[auto|unique]_ptr<X>\202

  iterator
  insert \201iterator position, std::[auto|unique]_ptr<X>\202

  std::[auto|unique]_ptr<X>
  detach_back \201bool pop = true\202;

  iterator
  detach \201iterator position,
          std::[auto|unique]_ptr<X>& result,
          bool erase = true\202

  ...
})RP(

  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 39 66 PR(void
f \201object& o\202
{
  using xml_schema::string;

  object::member_sequence& s \201o.member \201\202\202;

  // Iteration.
  //
  for \201object::member_iterator i \201s.begin \201\202\202; i != s.end \201\202; ++i\202
  {
    string& value \201*i\202;
  }

  // Modification.
  //
  s.push_back \201"hello"\202;  // deep copy

  // C++98 version.
  //
  std::auto_ptr<string> p \201new string \201"hello"\202\202;
  s.push_back \201p\202;        // assumes ownership
  p = s.detach_back \201\202;   // detach and pop
  s.push_back \201p\202;        // re-append

  // C++11 version.
  //
  std::unique_ptr<string> p \201new string \201"hello"\202\202;
  s.push_back \201std::move \201p\202\202; // assumes ownership
  p = s.detach_back \201\202;        // detach and pop
  s.push_back \201std::move \201p\202\202; // re-append)WR(

  // Setting a new container.
  //
  object::member_sequence n;
  n.push_back \201"one"\202;
  n.push_back \201"two"\202;
  o.member \201n\202;           // deep copy
})RP(

  )0 3 47 H(2.8.4)WB 144 Sn()WB 51 Sn( Element Order)EA()EH(

  )0 P(C++/Tree is a "flat)HY(ten)HY(ing)YH(" mapping in a sense that many levels of
     nested compos)HY(i)HY(tors)YH( \201)SM(choice)ES( and )SM(sequence)ES(\202,
     all poten)HY(tially)YH( with their own cardi)HY(nal)HY(i)HY(ties)YH(, are in the end mapped
     to a flat set of elements with one of the three cardi)HY(nal)HY(ity)YH( classes
     discussed in the previ)HY(ous)YH( sections. While this results in a simple
     and easy to use API for most types, in certain cases, the order of
     elements in the actual XML docu)HY(ments)YH( is not preserved once parsed
     into the object model. And some)HY(times)YH( such order has
     appli)HY(ca)HY(tion)YH(-specific signif)HY(i)HY(cance)YH(. As an example, consider a schema
     that defines a batch of bank trans)HY(ac)HY(tions)YH(:)EP(

  ) 20 48 PR(<complexType name="withdraw">
  <sequence>
    <element name="account" type="unsignedInt"/>
    <element name="amount" type="unsignedInt"/>
  </sequence>
</complexType>

<complexType name="deposit">
  <sequence>
    <element name="account" type="unsignedInt"/>
    <element name="amount" type="unsignedInt"/>
  </sequence>
</complexType>

<complexType name="batch">
  <choice minOccurs="0" maxOccurs="unbounded">
    <element name="withdraw" type="withdraw"/>
    <element name="deposit" type="deposit"/>
  </choice>
</complexType>)RP(

  )0 P(The batch can contain any number of trans)HY(ac)HY(tions)YH( in any order
     but the order of trans)HY(ac)HY(tions)YH( in each actual batch is signif)HY(i)HY(cant)YH(.
     For instance, consider what could happen if we reorder the
     trans)HY(ac)HY(tions)YH( and apply all the with)HY(drawals)YH( before deposits.)EP(

  )0 P(For the )SM(batch)ES( schema type defined above the default
     C++/Tree mapping will produce a C++ class that contains a pair of
     sequence contain)HY(ers)YH(, one for each of the two elements. While this
     will capture the content \201trans)HY(ac)HY(tions)YH(\202, the order of this content
     as it appears in XML will be lost. Also, if we try to seri)HY(al)HY(ize)YH( the
     batch we just loaded back to XML, all the with)HY(drawal)YH( trans)HY(ac)HY(tions)YH(
     will appear before deposits.)EP(

  )0 P(To over)HY(come)YH( this limi)HY(ta)HY(tion)YH( of a flat)HY(ten)HY(ing)YH( mapping, C++/Tree
     allows us to mark certain XML Schema types, for which content
     order is impor)HY(tant)YH(, as ordered.)EP(

  )0 P(There are several command line options that control which
     schema types are treated as ordered. To make an indi)HY(vid)HY(ual)YH(
     type ordered, we use the )SM(--ordered-type)ES( option,
     for example:)EP(

  ) 1 20 PR(--ordered-type batch)RP(

  )0 P(To auto)HY(mat)HY(i)HY(cally)YH( treat all the types that are derived from an ordered
     type also ordered, we use the )SM(--ordered-type-derived)ES(
     option. This is primar)HY(ily)YH( useful if you would like to iterate
     over the complete hier)HY(ar)HY(chy)YH('s content using the content order
     sequence \201discussed below\202.)EP(

  )0 P(Ordered types are also useful for handling mixed content. To
     auto)HY(mat)HY(i)HY(cally)YH( mark all the types with mixed content as ordered
     we use the )SM(--ordered-type-mixed)ES( option. For more
     infor)HY(ma)HY(tion)YH( on handling mixed content see )0 63 1 A(Section
     2.13, "Mapping for Mixed Content Models")63 0 TN TL()Ec /AF f D(.)EP(

  )0 P(Finally, we can mark all the types in the schema we are
     compil)HY(ing)YH( with the )SM(--ordered-type-all)ES( option.
     You should only resort to this option if all the types in
     your schema truly suffer from the loss of content
     order since, as we will discuss shortly, ordered types
     require extra effort to access and, espe)HY(cially)YH(, modify.
     See the
     )R8 2 A(XSD
     Compiler Command Line Manual)EA( for more infor)HY(ma)HY(tion)YH( on
     these options.)EP(

  )0 P(Once a type is marked ordered, C++/Tree alters its mapping
     in several ways. Firstly, for each local element, element
     wild)HY(card)YH( \201)0 61 1 A(Section 2.12.4, "Element Wild)HY(card)YH(
     Order")61 0 TN TL()Ec /AF f D(\202, and mixed content text \201)0 63 1 A(Section
     2.13, "Mapping for Mixed Content Models")63 0 TN TL()Ec /AF f D(\202 in this type, a
     content id constant is gener)HY(ated)YH(. Secondly, an addi)HY(tion)YH( sequence
     is added to the class that captures the content order. Here
     is how the mapping of our )SM(batch)ES( class changes
     once we make it ordered:)EP(

  ) 57 78 PR(class batch: public xml_schema::type
{
public:
  // withdraw
  //
  typedef withdraw withdraw_type;
  typedef sequence<withdraw_type> withdraw_sequence;
  typedef withdraw_sequence::iterator withdraw_iterator;
  typedef withdraw_sequence::const_iterator withdraw_const_iterator;

  static const std::size_t withdraw_id = 1;

  const withdraw_sequence&
  withdraw \201\202 const;

  withdraw_sequence&
  withdraw \201\202;

  void
  withdraw \201const withdraw_sequence&\202;

  // deposit
  //
  typedef deposit deposit_type;
  typedef sequence<deposit_type> deposit_sequence;
  typedef deposit_sequence::iterator deposit_iterator;
  typedef deposit_sequence::const_iterator deposit_const_iterator;

  static const std::size_t deposit_id = 2;

  const deposit_sequence&)WR(
  deposit \201\202 const;

  deposit_sequence&
  deposit \201\202;

  void
  deposit \201const deposit_sequence&\202;

  // content_order
  //
  typedef xml_schema::content_order content_order_type;
  typedef std::vector<content_order_type> content_order_sequence;
  typedef content_order_sequence::iterator content_order_iterator;
  typedef content_order_sequence::const_iterator content_order_const_iterator;

  const content_order_sequence&
  content_order \201\202 const;

  content_order_sequence&
  content_order \201\202;

  void
  content_order \201const content_order_sequence&\202;

  ...
};)RP(

  )0 P(Notice the )SM(with)HY(draw)YH(_id)ES( and )SM(deposit_id)ES(
     content ids as well as the extra )SM(content_order)ES(
     sequence that does not corre)HY(spond)YH( to any element in the
     schema defi)HY(ni)HY(tion)YH(. The other changes to the mapping for ordered
     types has to do with XML parsing and seri)HY(al)HY(iza)HY(tion)YH( code. During
     parsing the content order is captured in the )SM(content_order)ES(
     sequence while during seri)HY(al)HY(iza)HY(tion)YH( this sequence is used to
     deter)HY(mine)YH( the order in which content is seri)HY(al)HY(ized)YH(. The
     )SM(content_order)ES( sequence is also copied during
     copy construc)HY(tion)YH( and assigned during copy assign)HY(ment)YH(. It is also
     taken into account during compar)HY(i)HY(son)YH(.)EP(

  )0 P(The entry type of the )SM(content_order)ES( sequence is the
     )SM(xml_schema::content_order)ES( type that has the follow)HY(ing)YH(
     inter)HY(face)YH(:)EP(

  ) 19 58 PR(namespace xml_schema
{
  struct content_order
  {
    content_order \201std::size_t id, std::size_t index = 0\202;

    std::size_t id;
    std::size_t index;
  };

  bool
  operator== \201const content_order&, const content_order&\202;

  bool
  operator!= \201const content_order&, const content_order&\202;

  bool
  operator< \201const content_order&, const content_order&\202;
})RP(

  )0 P(The )SM(content_order)ES( sequence describes the order of
     content \201elements, includ)HY(ing)YH( wild)HY(cards)YH(, as well as mixed content
     text\202. Each entry in this sequence consists of the content id
     \201for example, )SM(with)HY(draw)YH(_id)ES( or )SM(deposit_id)ES(
     in our case\202 as well as, for elements of the sequence cardi)HY(nal)HY(ity)YH(
     class, an index into the corre)HY(spond)HY(ing)YH( sequence container \201the
     index is unused for the one and optional cardi)HY(nal)HY(ity)YH( classes\202.
     For example, in our case, if the content id is )SM(with)HY(draw)YH(_id)ES(,
     then the index will point into the )SM(with)HY(draw)YH()ES( element
     sequence.)EP(

  )0 P(With all this infor)HY(ma)HY(tion)YH( we can now examine how to iterate over
     trans)HY(ac)HY(tion)YH( in the batch in content order:)EP(

  ) 26 73 PR(batch& b = ...

for \201batch::content_order_const_iterator i \201b.content_order \201\202.begin \201\202\202;
     i != b.content_order \201\202.end \201\202;
     ++i\202
{
  switch \201i->id\202
  {
  case batch::withdraw_id:
    {
      const withdraw& t \201b.withdraw \201\202[i->index]\202;
      cerr << t.account \201\202 << " withdraw " << t.amount \201\202 << endl;
      break;
    }
  case batch::deposit_id:
    {
      const deposit& t \201b.deposit \201\202[i->index]\202;
      cerr << t.account \201\202 << " deposit " << t.amount \201\202 << endl;
      break;
    }
  default:
    {
      assert \201false\202; // Unknown content id.
    }
  }
})RP(

  )0 P(If we seri)HY(al)HY(ized)YH( our batch back to XML, we would also see that the
     order of trans)HY(ac)HY(tions)YH( in the output is exactly the same as in the
     input rather than all the with)HY(drawals)YH( first followed by all the
     deposits.)EP(

  )0 P(The most complex aspect of working with ordered types is
     modi)HY(fi)HY(ca)HY(tions)YH(. Now we not only need to change the content,
     but also remem)HY(ber)YH( to update the order infor)HY(ma)HY(tion)YH( corre)HY(spond)HY(ing)YH(
     to this change. As a first example, we add a deposit trans)HY(ac)HY(tion)YH(
     to the batch:)EP(

  ) 8 64 PR(using xml_schema::content_order;

batch::deposit_sequence& d \201b.deposit \201\202\202;
batch::withdraw_sequence& w \201b.withdraw \201\202\202;
batch::content_order_sequence& co \201b.content_order \201\202\202;

d.push_back \201deposit \201123456789, 100000\202\202;
co.push_back \201content_order \201batch::deposit_id, d.size \201\202 - 1\202\202;)RP(

  )0 P(In the above example we first added the content \201deposit
     trans)HY(ac)HY(tion)YH(\202 and then updated the content order infor)HY(ma)HY(tion)YH(
     by adding an entry with )SM(deposit_id)ES( content
     id and the index of the just added deposit trans)HY(ac)HY(tion)YH(.)EP(

  )0 P(Remov)HY(ing)YH( the last trans)HY(ac)HY(tion)YH( can be easy if we know which
     trans)HY(ac)HY(tion)YH( \201deposit or with)HY(drawal)YH(\202 is last:)EP(

  ) 2 15 PR(d.pop_back \201\202;
co.pop_back \201\202;)RP(

  )0 P(If, however, we do not know which trans)HY(ac)HY(tion)YH( is last, then
     things get a bit more compli)HY(cated)YH(:)EP(

  ) 15 24 PR(switch \201co.back \201\202.id\202
{
case batch::withdraw_id:
  {
    d.pop_back \201\202;
    break;
  }
case batch::deposit_id:
  {
    w.pop_back \201\202;
    break;
  }
}

co.pop_back \201\202;)RP(

  )0 P(The follow)HY(ing)YH( example shows how to add a trans)HY(ac)HY(tion)YH( at the
     begin)HY(ning)YH( of the batch:)EP(

  ) 3 62 PR(w.push_back \201withdraw \201123456789, 100000\202\202;
co.insert \201co.begin \201\202,
           content_order \201batch::withdraw_id, w.size \201\202 - 1\202\202;)RP(

  )0 P(Note also that when we merely modify the content of one
     of the elements in place, we do not need to update its
     order since it doesn't change. For example, here is how
     we can change the amount in the first with)HY(drawal)YH(:)EP(

  ) 1 20 PR(w[0].amount \20110000\202;)RP(

  )0 P(For the complete working code shown in this section refer to the
     )SM(order/element)ES( example in the
     )SM(exam)HY(ples)YH(/cxx/tree/)ES( direc)HY(tory)YH( in the XSD distri)HY(bu)HY(tion)YH(.)EP(

  )0 P(If both the base and derived types are ordered, then the
     content order sequence is only added to the base and the content
     ids are unique within the whole hier)HY(ar)HY(chy)YH(. In this case
     the content order sequence for the derived type contains
     order)HY(ing)YH( infor)HY(ma)HY(tion)YH( for both base and derived content.)EP(

  )0 P(In some appli)HY(ca)HY(tions)YH( we may need to perform more complex
     content process)HY(ing)YH(. For example, in our case, we may need
     to remove all the with)HY(drawal)YH( trans)HY(ac)HY(tions)YH(. The default
     container, )SM(std::vector)ES(, is not partic)HY(u)HY(larly)YH(
     suit)HY(able)YH( for such oper)HY(a)HY(tions)YH(. What may be required by
     some appli)HY(ca)HY(tions)YH( is a multi-index container that not
     only allows us to iterate in content order similar to
     )SM(std::vector)ES( but also search by the content
     id as well as the content id and index pair.)EP(

  )0 P(While C++/Tree does not provide this func)HY(tion)HY(al)HY(ity)YH( by
     default, it allows us to specify a custom container
     type for content order with the )SM(--order-container)ES(
     command line option. The only require)HY(ment)YH( from the
     gener)HY(ated)YH( code side for such a container is to provide
     the )SM(vector)ES(-like )SM(push_back\201\202)ES(,
     )SM(size\201\202)ES(, and const iter)HY(a)HY(tion)YH( inter)HY(faces)YH(.)EP(

  )0 P(As an example, here is how we can use the Boost Multi-Index
     container for content order. First we create the
     )SM(content-order-container.hxx)ES( header with the
     follow)HY(ing)YH( defi)HY(ni)HY(tion)YH( \201in C++11, use the alias template
     instead\202:)EP(

  ) 33 58 PR(#ifndef CONTENT_ORDER_CONTAINER
#define CONTENT_ORDER_CONTAINER

#include <cstddef> // std::size_t

#include <boost/multi_index_container.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/identity.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/random_access_index.hpp>

struct by_id {};
struct by_id_index {};

template <typename T>
struct content_order_container:
  boost::multi_index::multi_index_container<
    T,
    boost::multi_index::indexed_by<
      boost::multi_index::random_access<>,
      boost::multi_index::ordered_unique<
        boost::multi_index::tag<by_id_index>,
        boost::multi_index::identity<T>
      >,
      boost::multi_index::ordered_non_unique<
        boost::multi_index::tag<by_id>,
        boost::multi_index::member<T, std::size_t, &T::id>
      >
    >
  >
{};)WR(

#endif)RP(

  )0 P(Next we add the follow)HY(ing)YH( two XSD compiler options to include
     this header into every gener)HY(ated)YH( header file and to use the
     custom container type \201see the XSD compiler command line manual
     for more infor)HY(ma)HY(tion)YH( on shell quoting for the first option\202:)EP(

  ) 2 55 PR(--hxx-prologue '#include "content-order-container.hxx"'
--order-container content_order_container)RP(

  )0 P(With these changes we can now use the multi-index func)HY(tion)HY(al)HY(ity)YH(,
     for example, to search for a specific content id:)EP(

  ) 13 65 PR(typedef batch::content_order_sequence::index<by_id>::type id_set;
typedef id_set::iterator id_iterator;

const id_set& ids \201b.content_order \201\202.get<by_id> \201\202\202;

std::pair<id_iterator, id_iterator> r \201
  ids.equal_range \201std::size_t \201batch::deposit_id\202\202;

for \201id_iterator i \201r.first\202; i != r.second; ++i\202
{
  const deposit& t \201b.deposit \201\202[i->index]\202;
  cerr << t.account \201\202 << " deposit " << t.amount \201\202 << endl;
})RP(

  )0 2 48 H(2.9)WB 145 Sn()WB 52 Sn( Mapping for Global Elements)EA()EH(

  )0 P(An XML Schema element defi)HY(ni)HY(tion)YH( is called global if it appears
     directly under the )SM(schema)ES( element.
     A global element is a valid root of an instance docu)HY(ment)YH(. By
     default, a global element is mapped to a set of over)HY(loaded)YH(
     parsing and, option)HY(ally)YH(, seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( with the
     same name as the element. It is also possi)HY(ble)YH( to gener)HY(ate)YH( types
     for root elements instead of parsing and seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(.
     This is primar)HY(ily)YH( useful to distin)HY(guish)YH( object models with the
     same root type but with differ)HY(ent)YH( root elements. See
     )0 53 1 A(Section 2.9.1, "Element Types")53 0 TN TL()Ec /AF f D( for details.
     It is also possi)HY(ble)YH( to request the gener)HY(a)HY(tion)YH( of an element map
     which allows uniform parsing and seri)HY(al)HY(iza)HY(tion)YH( of multi)HY(ple)YH( root
     elements. See )0 54 1 A(Section 2.9.2, "Element Map")54 0 TN TL()Ec /AF f D(
     for details.
  )EP(

  )0 P(The parsing func)HY(tions)YH( read XML instance docu)HY(ments)YH( and return
     corre)HY(spond)HY(ing)YH( object models as an auto)HY(matic)YH( pointer
     \201)SM(std::auto_ptr)ES( or )SM(std::unique_ptr)ES(,
     depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected\202. Their signa)HY(tures)YH(
     have the follow)HY(ing)YH( pattern \201)SM(type)ES( denotes
     element's type and )SM(name)ES( denotes element's
     name\202:
  )EP(

  ) 2 28 PR(std::[auto|unique]_ptr<type>
name \201....\202;)RP(

  )0 P(The process of parsing, includ)HY(ing)YH( the exact signa)HY(tures)YH( of the parsing
     func)HY(tions)YH(, is the subject of )0 64 1 A(Chapter 3, "Parsing")64 0 TN TL()Ec /AF f D(.
  )EP(

  )0 P(The seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( write object models back to XML instance
     docu)HY(ments)YH(. Their signa)HY(tures)YH( have the follow)HY(ing)YH( pattern:
  )EP(

  ) 2 41 PR(void
name \201<stream type>&, const type&, ....\202;)RP(

  )0 P(The process of seri)HY(al)HY(iza)HY(tion)YH(, includ)HY(ing)YH( the exact signa)HY(tures)YH( of the
     seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(, is the subject of )0 81 1 A(Chapter 4,
     "Seri)HY(al)HY(iza)HY(tion)YH(")81 0 TN TL()Ec /AF f D(.
  )EP(


  )0 3 49 H(2.9.1)WB 146 Sn()WB 53 Sn( Element Types)EA()EH(

  )0 P(The gener)HY(a)HY(tion)YH( of element types is requested with the
     )SM(--gener)HY(ate)YH(-element-map)ES( option. With this option
     each global element is mapped to a C++ class with the
     same name as the element. Such a class is derived from
     )SM(xml_schema::element_type)ES( and contains the same set
     of type defi)HY(ni)HY(tions)YH(, construc)HY(tors)YH(, and member func)HY(tion)YH( as would a
     type contain)HY(ing)YH( a single element with the One cardi)HY(nal)HY(ity)YH( class
     named )SM("value")ES(. In addi)HY(tion)YH(, the element type also
     contains a set of member func)HY(tions)YH( for access)HY(ing)YH( the element
     name and names)HY(pace)YH( as well as its value in a uniform manner.
     For example:)EP(

  ) 7 34 PR(<complexType name="type">
  <sequence>
    ...
  </sequence>
</complexType>

<element name="root" type="type"/>)RP(

)0 P(is mapped to:)EP(

  ) 62 59 PR(class type
{
  ...
};

class root: public xml_schema::element_type
{
public:
  // Element value.
  //
  typedef type value_type;

  const value_type&
  value \201\202 const;

  value_type&
  value \201\202;

  void
  value \201const value_type&\202;

  void
  value \201std::[auto|unique]_ptr<value_type>\202;

  // Constructors.
  //
  root \201const value_type&\202;

  root \201std::[auto|unique]_ptr<value_type>\202;

  root \201const xercesc::DOMElement&, xml_schema::flags = 0\202;)WR(

  root \201const root&, xml_schema::flags = 0\202;

  virtual root*
  _clone \201xml_schema::flags = 0\202 const;

  // Element name and namespace.
  //
  static const std::string&
  name \201\202;

  static const std::string&
  namespace_ \201\202;

  virtual const std::string&
  _name \201\202 const;

  virtual const std::string&
  _namespace \201\202 const;

  // Element value as xml_schema::type.
  //
  virtual const xml_schema::type*
  _value \201\202 const;

  virtual xml_schema::type*
  _value \201\202;
};

void)WR(
operator<< \201xercesc::DOMElement&, const root&\202;)RP(

  )0 P(The )SM(xml_schema::element_type)ES( class is a common
     base type for all element types and is defined as follows:)EP(

  ) 24 39 PR(namespace xml_schema
{
  class element_type
  {
  public:
    virtual
    ~element_type \201\202;

    virtual element_type*
    _clone \201flags f = 0\202 const = 0;

    virtual const std::basic_string<C>&
    _name \201\202 const = 0;

    virtual const std::basic_string<C>&
    _namespace \201\202 const = 0;

    virtual xml_schema::type*
    _value \201\202 = 0;

    virtual const xml_schema::type*
    _value \201\202 const = 0;
  };
})RP(

  )0 P(The )SM(_value\201\202)ES( member func)HY(tion)YH( returns a pointer to
     the element value or 0 if the element is of a funda)HY(men)HY(tal)YH( C++
     type and there)HY(fore)YH( is not derived from )SM(xml_schema::type)ES(.
  )EP(

  )0 P(Unlike parsing and seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(, element types
     are only capable of parsing and seri)HY(al)HY(iz)HY(ing)YH( from/to a
     )SM(DOMEle)HY(ment)YH()ES( object. This means that the appli)HY(ca)HY(tion)YH(
     will need to perform its own XML-to-DOM parsing and DOM-to-XML
     seri)HY(al)HY(iza)HY(tion)YH(. The follow)HY(ing)YH( section describes a mech)HY(a)HY(nism)YH(
     provided by the mapping to uniformly parse and seri)HY(al)HY(ize)YH(
     multi)HY(ple)YH( root elements.)EP(


  )0 3 50 H(2.9.2)WB 147 Sn()WB 54 Sn( Element Map)EA()EH(

  )0 P(When element types are gener)HY(ated)YH( for root elements it is also
     possi)HY(ble)YH( to request the gener)HY(a)HY(tion)YH( of an element map with the
     )SM(--gener)HY(ate)YH(-element-map)ES( option. The element map
     allows uniform parsing and seri)HY(al)HY(iza)HY(tion)YH( of multi)HY(ple)YH( root
     elements via the common )SM(xml_schema::element_type)ES(
     base type. The )SM(xml_schema::element_map)ES( class is
     defined as follows:)EP(

  ) 12 59 PR(namespace xml_schema
{
  class element_map
  {
  public:
    static std::[auto|unique]_ptr<xml_schema::element_type>
    parse \201const xercesc::DOMElement&, flags = 0\202;

    static void
    serialize \201xercesc::DOMElement&, const element_type&\202;
  };
})RP(

  )0 P(The )SM(parse\201\202)ES( func)HY(tion)YH( creates the corre)HY(spond)HY(ing)YH(
     element type object based on the element name and names)HY(pace)YH(
     and returns it as an auto)HY(matic)YH( pointer \201)SM(std::auto_ptr)ES(
     or )SM(std::unique_ptr)ES(, depend)HY(ing)YH( on the C++ stan)HY(dard)YH(
     selected\202 to )SM(xml_schema::element_type)ES(.
     The )SM(seri)HY(al)HY(ize)YH(\201\202)ES( func)HY(tion)YH( seri)HY(al)HY(izes)YH( the passed element
     object to )SM(DOMEle)HY(ment)YH()ES(. Note that in case of
     )SM(seri)HY(al)HY(ize)YH(\201\202)ES(, the )SM(DOMEle)HY(ment)YH()ES( object
     should have the correct name and names)HY(pace)YH(. If no element type is
     avail)HY(able)YH( for an element, both func)HY(tions)YH( throw the
     )SM(xml_schema::no_element_info)ES( excep)HY(tion)YH(:)EP(

  ) 14 66 PR(struct no_element_info: virtual exception
{
  no_element_info \201const std::basic_string<C>& element_name,
                   const std::basic_string<C>& element_namespace\202;

  const std::basic_string<C>&
  element_name \201\202 const;

  const std::basic_string<C>&
  element_namespace \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The appli)HY(ca)HY(tion)YH( can discover the actual type of the element
     object returned by )SM(parse\201\202)ES( either using
     )SM(dynamic_cast)ES( or by compar)HY(ing)YH( element names and
     names)HY(paces)YH(. The follow)HY(ing)YH( code frag)HY(ments)YH( illus)HY(trate)YH( how the
     element map can be used:)EP(

  ) 18 50 PR(// Parsing.
//
DOMElement& e = ... // Parse XML to DOM.

auto_ptr<xml_schema::element_type> r \201
  xml_schema::element_map::parse \201e\202\202;

if \201root1 r1 = dynamic_cast<root1*> \201r.get \201\202\202\202
{
  ...
}
else if \201r->_name == root2::name \201\202 &&
         r->_namespace \201\202 == root2::namespace_ \201\202\202
{
  root2& r2 \201static_cast<root2&> \201*r\202\202;

  ...
})RP(

  ) 13 68 PR(// Serialization.
//
xml_schema::element_type& r = ...

string name \201r._name \201\202\202;
string ns \201r._namespace \201\202\202;

DOMDocument& doc = ... // Create a new DOMDocument with name and ns.
DOMElement& e \201*doc->getDocumentElement \201\202\202;

xml_schema::element_map::serialize \201e, r\202;

// Serialize DOMDocument to XML.)RP(

  

  )0 2 51 H(2.10)WB 148 Sn()WB 55 Sn( Mapping for Global Attributes)EA()EH(

  )0 P(An XML Schema attribute defi)HY(ni)HY(tion)YH( is called global if it appears
     directly under the )SM(schema)ES( element. A global
     attribute does not have any mapping.
  )EP(

  

  )0 2 52 H(2.11)WB 149 Sn()WB 56 Sn( Mapping for )SM(xsi:type)ES( and Substi)HY(tu)HY(tion)YH(
      Groups)EA()EH(

  )0 P(The mapping provides optional support for the XML Schema poly)HY(mor)HY(phism)YH(
     features \201)SM(xsi:type)ES( and substi)HY(tu)HY(tion)YH( groups\202 which can
     be requested with the )SM(--gener)HY(ate)YH(-poly)HY(mor)HY(phic)YH()ES( option.
     When used, the dynamic type of a member may be differ)HY(ent)YH( from
     its static type. Consider the follow)HY(ing)YH( schema defi)HY(ni)HY(tion)YH( and
     instance docu)HY(ment)YH(:
  )EP(

  ) 28 62 PR(<!-- test.xsd -->
<schema>
  <complexType name="base">
    <attribute name="text" type="string"/>
  </complexType>

  <complexType name="derived">
    <complexContent>
      <extension base="base">
        <attribute name="extra-text" type="string"/>
      </extension>
    </complexContent>
  </complexType>

  <complexType name="root_type">
    <sequence>
      <element name="item" type="base" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <element name="root" type="root_type"/>
</schema>

<!-- test.xml -->
<root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <item text="hello"/>
  <item text="hello" extra-text="world" xsi:type="derived"/>
</root>)RP(

  )0 P(In the result)HY(ing)YH( object model, the container for
     the )SM(root::item)ES( member will have two elements:
     the first element's type will be )SM(base)ES( while
     the second element's \201dynamic\202 type will be
     )SM(derived)ES(. This can be discov)HY(ered)YH( using the
     )SM(dynamic_cast)ES( oper)HY(a)HY(tor)YH( as shown in the follow)HY(ing)YH(
     example:
  )EP(

  ) 17 56 PR(void
f \201root& r\202
{
  for \201root::item_const_iterator i \201r.item \201\202.begin \201\202\202;
       i != r.item \201\202.end \201\202
       ++i\202
  {
    if \201derived* d = dynamic_cast<derived*> \201&\201*i\202\202\202
    {
      // derived
    }
    else
    {
      // base
    }
  }
})RP(

  )0 P(The )SM(_clone)ES( virtual func)HY(tion)YH( should be used instead of
     copy construc)HY(tors)YH( to make copies of members that might use
     poly)HY(mor)HY(phism)YH(:
  )EP(

  ) 10 56 PR(void
f \201root& r\202
{
  for \201root::item_const_iterator i \201r.item \201\202.begin \201\202\202;
       i != r.item \201\202.end \201\202
       ++i\202
  {
    std::auto_ptr<base> c \201i->_clone \201\202\202;
  }
})RP(

  )0 P(The mapping can often auto)HY(mat)HY(i)HY(cally)YH( deter)HY(mine)YH( which types are
     poly)HY(mor)HY(phic)YH( based on the substi)HY(tu)HY(tion)YH( group decla)HY(ra)HY(tions)YH(. However,
     if your XML vocab)HY(u)HY(lary)YH( is not using substi)HY(tu)HY(tion)YH( groups or if
     substi)HY(tu)HY(tion)YH( groups are defined in a sepa)HY(rate)YH( schema, then you will
     need to use the )SM(--poly)HY(mor)HY(phic)YH(-type)ES( option to specify
     which types are poly)HY(mor)HY(phic)YH(. When using this option you only need
     to specify the root of a poly)HY(mor)HY(phic)YH( type hier)HY(ar)HY(chy)YH( and the mapping
     will assume that all the derived types are also poly)HY(mor)HY(phic)YH(.
     Also note that you need to specify this option when compil)HY(ing)YH( every
     schema file that refer)HY(ences)YH( the poly)HY(mor)HY(phic)YH( type. Consider the follow)HY(ing)YH(
     two schemas as an example:)EP(

  ) 13 55 PR(<!-- base.xsd -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:complexType name="base">
    <xs:sequence>
      <xs:element name="b" type="xs:int"/>
    </xs:sequence>
  </xs:complexType>

  <!-- substitution group root -->
  <xs:element name="base" type="base"/>

</xs:schema>)RP(

  ) 18 70 PR(<!-- derived.xsd -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <include schemaLocation="base.xsd"/>

  <xs:complexType name="derived">
    <xs:complexContent>
      <xs:extension base="base">
        <xs:sequence>
          <xs:element name="d" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="derived" type="derived" substitutionGroup="base"/>

</xs:schema>)RP(

  )0 P(In this example we need to specify ")SM(--poly)HY(mor)HY(phic)YH(-type base)ES("
     when compil)HY(ing)YH( both schemas because the substi)HY(tu)HY(tion)YH( group is declared
     in a schema other than the one defin)HY(ing)YH( type )SM(base)ES(.)EP(

  )0 P(You can also indi)HY(cate)YH( that all types should be treated as poly)HY(mor)HY(phic)YH(
     with the )SM(--poly)HY(mor)HY(phic)YH(-type-all)ES(. However, this may result
     in slower gener)HY(ated)YH( code with a greater foot)HY(print)YH(.)EP(


  


  )0 2 53 H(2.12)WB 150 Sn()WB 57 Sn( Mapping for )SM(any)ES( and )SM(anyAt)HY(tribute)YH()ES()EA()EH(

  )0 P(For the XML Schema )SM(any)ES( and )SM(anyAt)HY(tribute)YH()ES(
     wild)HY(cards)YH( an optional mapping can be requested with the
     )SM(--gener)HY(ate)YH(-wild)HY(card)YH()ES( option. The mapping repre)HY(sents)YH(
     the content matched by wild)HY(cards)YH( as DOM frag)HY(ments)YH(. Because the
     DOM API is used to access such content, the Xerces-C++ runtime
     should be initial)HY(ized)YH( by the appli)HY(ca)HY(tion)YH( prior to parsing and
     should remain initial)HY(ized)YH( for the life)HY(time)YH( of objects with
     the wild)HY(card)YH( content. For more infor)HY(ma)HY(tion)YH( on the Xerces-C++
     runtime initial)HY(iza)HY(tion)YH( see )0 65 1 A(Section 3.1,
     "Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime")65 0 TN TL()Ec /AF f D(.
  )EP(

  )0 P(The mapping for )SM(any)ES( is similar to the mapping for
     local elements \201see )0 47 1 A(Section 2.8, "Mapping for Local
     Elements and Attributes")47 0 TN TL()Ec /AF f D(\202 except that the type used in the
     wild)HY(card)YH( mapping is )SM(xercesc::DOMEle)HY(ment)YH()ES(. As with local
     elements, the mapping divides all possi)HY(ble)YH( cardi)HY(nal)HY(ity)YH( combi)HY(na)HY(tions)YH(
     into three cardi)HY(nal)HY(ity)YH( classes: )I(one)ES(, )I(optional)ES(, and
     )I(sequence)ES(.
  )EP(

  )0 P(The mapping for )SM(anyAt)HY(tribute)YH()ES( repre)HY(sents)YH( the attributes
     matched by this wild)HY(card)YH( as a set of )SM(xercesc::DOMAttr)ES(
     objects with a key being the attribute's name and names)HY(pace)YH(.)EP(

  )0 P(Similar to local elements and attributes, the )SM(any)ES( and
     )SM(anyAt)HY(tribute)YH()ES( wild)HY(cards)YH( are mapped to a set of public type
     defi)HY(ni)HY(tions)YH( \201type)HY(defs)YH(\202 and a set of public acces)HY(sor)YH( and modi)HY(fier)YH(
     func)HY(tions)YH(. Type defi)HY(ni)HY(tions)YH( have names derived from )SM("any")ES(
     for the )SM(any)ES( wild)HY(card)YH( and )SM("any_attribute")ES(
     for the )SM(anyAt)HY(tribute)YH()ES( wild)HY(card)YH(. The acces)HY(sor)YH( and modi)HY(fier)YH(
     func)HY(tions)YH( are named )SM("any")ES( for the )SM(any)ES( wild)HY(card)YH(
     and )SM("any_attribute")ES( for the )SM(anyAt)HY(tribute)YH()ES(
     wild)HY(card)YH(. Subse)HY(quent)YH( wild)HY(cards)YH( in the same type have escaped names
     such as )SM("any1")ES( or )SM("any_attribute1")ES(.
  )EP(

  )0 P(Because Xerces-C++ DOM nodes always belong to a )SM(DOMDoc)HY(u)HY(ment)YH()ES(,
     each type with a wild)HY(card)YH( has an asso)HY(ci)HY(ated)YH( )SM(DOMDoc)HY(u)HY(ment)YH()ES(
     object. The refer)HY(ence)YH( to this object can be obtained using the acces)HY(sor)YH(
     func)HY(tion)YH( called )SM(dom_docu)HY(ment)YH()ES(. The access to the docu)HY(ment)YH(
     object from the appli)HY(ca)HY(tion)YH( code may be neces)HY(sary)YH( to create or modify
     the wild)HY(card)YH( content. For example:
  )EP(

  ) 6 37 PR(<complexType name="object">
  <sequence>
    <any namespace="##other"/>
  </sequence>
  <anyAttribute namespace="##other"/>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 37 73 PR(class object: public xml_schema::type
{
public:
  // any
  //
  const xercesc::DOMElement&
  any \201\202 const;

  void
  any \201const xercesc::DOMElement&\202;

  ...

  // any_attribute
  //
  typedef attribute_set any_attribute_set;
  typedef any_attribute_set::iterator any_attribute_iterator;
  typedef any_attribute_set::const_iterator any_attribute_const_iterator;

  const any_attribute_set&
  any_attribute \201\202 const;

  any_attribute_set&
  any_attribute \201\202;

  ...

  // DOMDocument object for wildcard content.
  //
  const xercesc::DOMDocument&
  dom_document \201\202 const;)WR(

  xercesc::DOMDocument&
  dom_document \201\202;

  ...
};)RP(


  )0 P(Names and seman)HY(tics)YH( of type defi)HY(ni)HY(tions)YH( for the wild)HY(cards)YH( as well
     as signa)HY(tures)YH( of the acces)HY(sor)YH( and modi)HY(fier)YH( func)HY(tions)YH( depend on the
     wild)HY(card)YH( type as well as the cardi)HY(nal)HY(ity)YH( class for the )SM(any)ES(
     wild)HY(card)YH(. They are described in the follow)HY(ing)YH( sub-sections.
  )EP(


  )0 3 54 H(2.12.1)WB 151 Sn()WB 58 Sn( Mapping for )SM(any)ES( with the One Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

  )0 P(For )SM(any)ES( with the One cardi)HY(nal)HY(ity)YH( class,
     there are no type defi)HY(ni)HY(tions)YH(. The acces)HY(sor)YH( func)HY(tions)YH( come in
     constant and non-constant versions. The constant acces)HY(sor)YH( func)HY(tion)YH(
     returns a constant refer)HY(ence)YH( to )SM(xercesc::DOMEle)HY(ment)YH()ES( and
     can be used for read-only access. The non-constant version returns
     an unre)HY(stricted)YH( refer)HY(ence)YH( to )SM(xercesc::DOMEle)HY(ment)YH()ES( and can
     be used for read-write access.
  )EP(

  )0 P(The first modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of type refer)HY(ence)YH(
     to constant )SM(xercesc::DOMEle)HY(ment)YH()ES( and makes a deep copy
     of its argu)HY(ment)YH(. The second modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of
     type pointer to )SM(xercesc::DOMEle)HY(ment)YH()ES(. This modi)HY(fier)YH(
     func)HY(tion)YH( assumes owner)HY(ship)YH( of its argu)HY(ment)YH( and expects the element
     object to be created using the DOM docu)HY(ment)YH( asso)HY(ci)HY(ated)YH( with this
     instance. For example:
  )EP(

  ) 5 30 PR(<complexType name="object">
  <sequence>
    <any namespace="##other"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 22 37 PR(class object: public xml_schema::type
{
public:
  // Accessors.
  //
  const xercesc::DOMElement&
  any \201\202 const;

  xercesc::DOMElement&
  any \201\202;

  // Modifiers.
  //
  void
  any \201const xercesc::DOMElement&\202;

  void
  any \201xercesc::DOMElement*\202;

  ...

};)RP(


  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 10 66 PR(void
f \201object& o, const xercesc::DOMElement& e\202
{
  using namespace xercesc;

  DOMElement& e1 \201o.any \201\202\202;             // get
  o.any \201e\202                              // set, deep copy
  DOMDocument& doc \201o.dom_document \201\202\202;
  o.any \201doc.createElement \201...\202\202;       // set, assumes ownership
})RP(

  )0 3 55 H(2.12.2)WB 152 Sn()WB 59 Sn( Mapping for )SM(any)ES( with the Optional Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

  )0 P(For )SM(any)ES( with the Optional cardi)HY(nal)HY(ity)YH( class, the type
     defi)HY(ni)HY(tions)YH( consist of an alias for the container type with name
     )SM(any_optional)ES( \201or )SM(any1_optional)ES(, etc., for
     subse)HY(quent)YH( wild)HY(cards)YH( in the type defi)HY(ni)HY(tion)YH(\202.
  )EP(

  )0 P(Unlike acces)HY(sor)YH( func)HY(tions)YH( for the One cardi)HY(nal)HY(ity)YH( class, acces)HY(sor)YH(
     func)HY(tions)YH( for the Optional cardi)HY(nal)HY(ity)YH( class return refer)HY(ences)YH( to
     corre)HY(spond)HY(ing)YH( contain)HY(ers)YH( rather than directly to )SM(DOMEle)HY(ment)YH()ES(.
     The acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
     The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to
     the container and can be used for read-only access. The non-constant
     version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the container
     and can be used for read-write access.
  )EP(

  )0 P(The modi)HY(fier)YH( func)HY(tions)YH( are over)HY(loaded)YH( for )SM(xercesc::DOMEle)HY(ment)YH()ES(
     and the container type. The first modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of
     type refer)HY(ence)YH( to constant )SM(xercesc::DOMEle)HY(ment)YH()ES( and
     makes a deep copy of its argu)HY(ment)YH(. The second modi)HY(fier)YH( func)HY(tion)YH(
     expects an argu)HY(ment)YH( of type pointer to )SM(xercesc::DOMEle)HY(ment)YH()ES(.
     This modi)HY(fier)YH( func)HY(tion)YH( assumes owner)HY(ship)YH( of its argu)HY(ment)YH( and expects
     the element object to be created using the DOM docu)HY(ment)YH( asso)HY(ci)HY(ated)YH(
     with this instance. The third modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH(
     of type refer)HY(ence)YH( to constant of the container type and makes a
     deep copy of its argu)HY(ment)YH(. For instance:
  )EP(

  ) 5 44 PR(<complexType name="object">
  <sequence>
    <any namespace="##other" minOccurs="0"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 29 40 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef element_optional any_optional;

  // Accessors.
  //
  const any_optional&
  any \201\202 const;

  any_optional&
  any \201\202;

  // Modifiers.
  //
  void
  any \201const xercesc::DOMElement&\202;

  void
  any \201xercesc::DOMElement*\202;

  void
  any \201const any_optional&\202;

  ...

};)RP(


  )0 P(The )SM(element_optional)ES( container is a
     special)HY(iza)HY(tion)YH( of the )SM(optional)ES( class template described
     in )0 49 1 A(Section 2.8.2, "Mapping for Members with the Optional
     Cardi)HY(nal)HY(ity)YH( Class")49 0 TN TL()Ec /AF f D(. Its inter)HY(face)YH( is presented below:
  )EP(

  ) 72 71 PR(class element_optional
{
public:
  explicit
  element_optional \201xercesc::DOMDocument&\202;

  // Makes a deep copy.
  //
  element_optional \201const xercesc::DOMElement&, xercesc::DOMDocument&\202;

  // Assumes ownership.
  //
  element_optional \201xercesc::DOMElement*, xercesc::DOMDocument&\202;

  element_optional \201const element_optional&, xercesc::DOMDocument&\202;

public:
  element_optional&
  operator= \201const xercesc::DOMElement&\202;

  element_optional&
  operator= \201const element_optional&\202;

  // Pointer-like interface.
  //
public:
  const xercesc::DOMElement*
  operator-> \201\202 const;

  xercesc::DOMElement*
  operator-> \201\202;)WR(

  const xercesc::DOMElement&
  operator* \201\202 const;

  xercesc::DOMElement&
  operator* \201\202;

  typedef void \201element_optional::*bool_convertible\202 \201\202;
  operator bool_convertible \201\202 const;

  // Get/set interface.
  //
public:
  bool
  present \201\202 const;

  const xercesc::DOMElement&
  get \201\202 const;

  xercesc::DOMElement&
  get \201\202;

  // Makes a deep copy.
  //
  void
  set \201const xercesc::DOMElement&\202;

  // Assumes ownership.
  //
  void)WR(
  set \201xercesc::DOMElement*\202;

  void
  reset \201\202;
};

bool
operator== \201const element_optional&, const element_optional&\202;

bool
operator!= \201const element_optional&, const element_optional&\202;)RP(


  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 25 69 PR(void
f \201object& o, const xercesc::DOMElement& e\202
{
  using namespace xercesc;

  DOMDocument& doc \201o.dom_document \201\202\202;

  if \201o.any \201\202.present \201\202\202                  // test
  {
    DOMElement& e1 \201o.any \201\202.get \201\202\202;       // get
    o.any \201\202.set \201e\202;                       // set, deep copy
    o.any \201\202.set \201doc.createElement \201...\202\202; // set, assumes ownership
    o.any \201\202.reset \201\202;                      // reset
  }

  // Same as above but using pointer notation:
  //
  if \201o.member \201\202\202                          // test
  {
    DOMElement& e1 \201*o.any \201\202\202;             // get
    o.any \201e\202;                              // set, deep copy
    o.any \201doc.createElement \201...\202\202;        // set, assumes ownership
    o.any \201\202.reset \201\202;                      // reset
  }
})RP(



  )0 3 56 H(2.12.3)WB 153 Sn()WB 60 Sn( Mapping for )SM(any)ES( with the Sequence Cardi)HY(nal)HY(ity)YH( Class)EA()EH(

  )0 P(For )SM(any)ES( with the Sequence cardi)HY(nal)HY(ity)YH( class, the type
     defi)HY(ni)HY(tions)YH( consist of an alias of the container type with name
     )SM(any_sequence)ES( \201or )SM(any1_sequence)ES(, etc., for
     subse)HY(quent)YH( wild)HY(cards)YH( in the type defi)HY(ni)HY(tion)YH(\202, an alias of the iter)HY(a)HY(tor)YH(
     type with name )SM(any_iter)HY(a)HY(tor)YH()ES( \201or )SM(any1_iter)HY(a)HY(tor)YH()ES(,
     etc., for subse)HY(quent)YH( wild)HY(cards)YH( in the type defi)HY(ni)HY(tion)YH(\202, and an alias
     of the constant iter)HY(a)HY(tor)YH( type with name )SM(any_const_iter)HY(a)HY(tor)YH()ES(
     \201or )SM(any1_const_iter)HY(a)HY(tor)YH()ES(, etc., for subse)HY(quent)YH( wild)HY(cards)YH(
     in the type defi)HY(ni)HY(tion)YH(\202.
  )EP(

  )0 P(The acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
     The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to the
     container and can be used for read-only access. The non-constant
     version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the container and can
     be used for read-write access.
  )EP(

  )0 P(The modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to
     constant of the container type. The modi)HY(fier)YH( func)HY(tion)YH( makes
     a deep copy of its argu)HY(ment)YH(. For instance:
  )EP(


  ) 5 52 PR(<complexType name="object">
  <sequence>
    <any namespace="##other" minOccurs="unbounded"/>
  </sequence>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 25 58 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef element_sequence any_sequence;
  typedef any_sequence::iterator any_iterator;
  typedef any_sequence::const_iterator any_const_iterator;

  // Accessors.
  //
  const any_sequence&
  any \201\202 const;

  any_sequence&
  any \201\202;

  // Modifier.
  //
  void
  any \201const any_sequence&\202;

  ...

};)RP(

  )0 P(The )SM(element_sequence)ES( container is a
     special)HY(iza)HY(tion)YH( of the )SM(sequence)ES( class template described
     in )0 50 1 A(Section 2.8.3, "Mapping for Members with the
     Sequence Cardi)HY(nal)HY(ity)YH( Class")50 0 TN TL()Ec /AF f D(. Its inter)HY(face)YH( is similar to
     the sequence inter)HY(face)YH( as defined by the ISO/ANSI Stan)HY(dard)YH( for
     C++ \201ISO/IEC 14882:1998, Section 23.1.1, "Sequences"\202 and is
     presented below:
  )EP(

  ) 178 70 PR(class element_sequence
{
public:
  typedef xercesc::DOMElement        value_type;
  typedef xercesc::DOMElement*       pointer;
  typedef const xercesc::DOMElement* const_pointer;
  typedef xercesc::DOMElement&       reference;
  typedef const xercesc::DOMElement& const_reference;

  typedef <implementation-defined>   iterator;
  typedef <implementation-defined>   const_iterator;
  typedef <implementation-defined>   reverse_iterator;
  typedef <implementation-defined>   const_reverse_iterator;

  typedef <implementation-defined>   size_type;
  typedef <implementation-defined>   difference_type;
  typedef <implementation-defined>   allocator_type;

public:
  explicit
  element_sequence \201xercesc::DOMDocument&\202;

  // DOMElement cannot be default-constructed.
  //
  // explicit
  // element_sequence \201size_type n\202;

  element_sequence \201size_type n,
                    const xercesc::DOMElement&,
                    xercesc::DOMDocument&\202;
)WR(
  template <typename I>
  element_sequence \201const I& begin,
                    const I& end,
                    xercesc::DOMDocument&\202;

  element_sequence \201const element_sequence&, xercesc::DOMDocument&\202;

  element_sequence&
  operator= \201const element_sequence&\202;

public:
  void
  assign \201size_type n, const xercesc::DOMElement&\202;

  template <typename I>
  void
  assign \201const I& begin, const I& end\202;

public:
  // This version of resize can only be used to shrink the
  // sequence because DOMElement cannot be default-constructed.
  //
  void
  resize \201size_type\202;

  void
  resize \201size_type, const xercesc::DOMElement&\202;

public:
  size_type)WR(
  size \201\202 const;

  size_type
  max_size \201\202 const;

  size_type
  capacity \201\202 const;

  bool
  empty \201\202 const;

  void
  reserve \201size_type\202;

  void
  clear \201\202;

public:
  const_iterator
  begin \201\202 const;

  const_iterator
  end \201\202 const;

  iterator
  begin \201\202;

  iterator
  end \201\202;
)WR(
  const_reverse_iterator
  rbegin \201\202 const;

  const_reverse_iterator
  rend \201\202 const

    reverse_iterator
  rbegin \201\202;

  reverse_iterator
  rend \201\202;

public:
  xercesc::DOMElement&
  operator[] \201size_type\202;

  const xercesc::DOMElement&
  operator[] \201size_type\202 const;

  xercesc::DOMElement&
  at \201size_type\202;

  const xercesc::DOMElement&
  at \201size_type\202 const;

  xercesc::DOMElement&
  front \201\202;

  const xercesc::DOMElement&
  front \201\202 const;)WR(

  xercesc::DOMElement&
  back \201\202;

  const xercesc::DOMElement&
  back \201\202 const;

public:
  // Makes a deep copy.
  //
  void
  push_back \201const xercesc::DOMElement&\202;

  // Assumes ownership.
  //
  void
  push_back \201xercesc::DOMElement*\202;

  void
  pop_back \201\202;

  // Makes a deep copy.
  //
  iterator
  insert \201iterator position, const xercesc::DOMElement&\202;

  // Assumes ownership.
  //
  iterator
  insert \201iterator position, xercesc::DOMElement*\202;)WR(

  void
  insert \201iterator position, size_type n, const xercesc::DOMElement&\202;

  template <typename I>
  void
  insert \201iterator position, const I& begin, const I& end\202;

  iterator
  erase \201iterator position\202;

  iterator
  erase \201iterator begin, iterator end\202;

public:
  // Note that the DOMDocument object of the two sequences being
  // swapped should be the same.
  //
  void
  swap \201sequence& x\202;
};

inline bool
operator== \201const element_sequence&, const element_sequence&\202;

inline bool
operator!= \201const element_sequence&, const element_sequence&\202;)RP(


  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 20 63 PR(void
f \201object& o, const xercesc::DOMElement& e\202
{
  using namespace xercesc;

  object::any_sequence& s \201o.any \201\202\202;

  // Iteration.
  //
  for \201object::any_iterator i \201s.begin \201\202\202; i != s.end \201\202; ++i\202
  {
    DOMElement& e \201*i\202;
  }

  // Modification.
  //
  s.push_back \201e\202;                       // deep copy
  DOMDocument& doc \201o.dom_document \201\202\202;
  s.push_back \201doc.createElement \201...\202\202; // assumes ownership
})RP(

  )0 3 57 H(2.12.4)WB 154 Sn()WB 61 Sn( Element Wild)HY(card)YH( Order)EA()EH(

  )0 P(Similar to elements, element wild)HY(cards)YH( in ordered types
     \201)0 51 1 A(Section 2.8.4, "Element Order")51 0 TN TL()Ec /AF f D(\202 are assigned
     content ids and are included in the content order sequence.
     Contin)HY(u)HY(ing)YH( with the bank trans)HY(ac)HY(tions)YH( example started in Section
     2.8.4, we can extend the batch by allow)HY(ing)YH( custom trans)HY(ac)HY(tions)YH(:)EP(

  ) 7 52 PR(<complexType name="batch">
  <choice minOccurs="0" maxOccurs="unbounded">
    <element name="withdraw" type="withdraw"/>
    <element name="deposit" type="deposit"/>
    <any namespace="##other" processContents="lax"/>
  </choice>
</complexType>)RP(

  )0 P(This will lead to the follow)HY(ing)YH( changes in the gener)HY(ated)YH(
     )SM(batch)ES( C++ class:)EP(

  ) 24 58 PR(class batch: public xml_schema::type
{
public:
  ...

  // any
  //
  typedef element_sequence any_sequence;
  typedef any_sequence::iterator any_iterator;
  typedef any_sequence::const_iterator any_const_iterator;

  static const std::size_t any_id = 3UL;

  const any_sequence&
  any \201\202 const;

  any_sequence&
  any \201\202;

  void
  any \201const any_sequence&\202;

  ...
};)RP(

  )0 P(With this change we also need to update the iter)HY(a)HY(tion)YH( code to handle
     the new content id:)EP(

  ) 18 73 PR(for \201batch::content_order_const_iterator i \201b.content_order \201\202.begin \201\202\202;
     i != b.content_order \201\202.end \201\202;
     ++i\202
{
  switch \201i->id\202
  {
    ...

  case batch::any_id:
    {
      const DOMElement& e \201b.any \201\202[i->index]\202;
      ...
      break;
    }

    ...
  }
})RP(

  )0 P(For the complete working code that shows the use of wild)HY(cards)YH( in
     ordered types refer to the )SM(order/element)ES( example in
     the )SM(exam)HY(ples)YH(/cxx/tree/)ES( direc)HY(tory)YH( in the XSD
     distri)HY(bu)HY(tion)YH(.)EP(

  )0 3 58 H(2.12.5)WB 155 Sn()WB 62 Sn( Mapping for )SM(anyAt)HY(tribute)YH()ES()EA()EH(

  )0 P(For )SM(anyAt)HY(tribute)YH()ES( the type defi)HY(ni)HY(tions)YH( consist of an alias
     of the container type with name )SM(any_attribute_set)ES(
     \201or )SM(any1_attribute_set)ES(, etc., for subse)HY(quent)YH( wild)HY(cards)YH(
     in the type defi)HY(ni)HY(tion)YH(\202, an alias of the iter)HY(a)HY(tor)YH( type with name
     )SM(any_attribute_iter)HY(a)HY(tor)YH()ES( \201or )SM(any1_attribute_iter)HY(a)HY(tor)YH()ES(,
     etc., for subse)HY(quent)YH( wild)HY(cards)YH( in the type defi)HY(ni)HY(tion)YH(\202, and an alias
     of the constant iter)HY(a)HY(tor)YH( type with name )SM(any_attribute_const_iter)HY(a)HY(tor)YH()ES(
     \201or )SM(any1_attribute_const_iter)HY(a)HY(tor)YH()ES(, etc., for subse)HY(quent)YH(
     wild)HY(cards)YH( in the type defi)HY(ni)HY(tion)YH(\202.
  )EP(

  )0 P(The acces)HY(sor)YH( func)HY(tions)YH( come in constant and non-constant versions.
     The constant acces)HY(sor)YH( func)HY(tion)YH( returns a constant refer)HY(ence)YH( to the
     container and can be used for read-only access. The non-constant
     version returns an unre)HY(stricted)YH( refer)HY(ence)YH( to the container and can
     be used for read-write access.
  )EP(

  )0 P(The modi)HY(fier)YH( func)HY(tion)YH( expects an argu)HY(ment)YH( of type refer)HY(ence)YH( to
     constant of the container type. The modi)HY(fier)YH( func)HY(tion)YH( makes
     a deep copy of its argu)HY(ment)YH(. For instance:
  )EP(


  ) 6 37 PR(<complexType name="object">
  <sequence>
    ...
  </sequence>
  <anyAttribute namespace="##other"/>
</complexType>)RP(

  )0 P(is mapped to:)EP(

  ) 25 73 PR(class object: public xml_schema::type
{
public:
  // Type definitions.
  //
  typedef attribute_set any_attribute_set;
  typedef any_attribute_set::iterator any_attribute_iterator;
  typedef any_attribute_set::const_iterator any_attribute_const_iterator;

  // Accessors.
  //
  const any_attribute_set&
  any_attribute \201\202 const;

  any_attribute_set&
  any_attribute \201\202;

  // Modifier.
  //
  void
  any_attribute \201const any_attribute_set&\202;

  ...

};)RP(

  )0 P(The )SM(attribute_set)ES( class is an asso)HY(cia)HY(tive)YH( container
     similar to the )SM(std::set)ES( class template as defined by
     the ISO/ANSI Stan)HY(dard)YH( for C++ \201ISO/IEC 14882:1998, Section 23.3.3,
     "Class template set"\202 with the key being the attribute's name
     and names)HY(pace)YH(. Unlike )SM(std::set)ES(, )SM(attribute_set)ES(
     allows search)HY(ing)YH( using names and names)HY(paces)YH( instead of
     )SM(xercesc::DOMAttr)ES( objects. It is defined in an
     imple)HY(men)HY(ta)HY(tion)YH(-specific names)HY(pace)YH( and its inter)HY(face)YH( is presented
     below:
  )EP(

  ) 166 70 PR(class attribute_set
{
public:
  typedef xercesc::DOMAttr         key_type;
  typedef xercesc::DOMAttr         value_type;
  typedef xercesc::DOMAttr*        pointer;
  typedef const xercesc::DOMAttr*  const_pointer;
  typedef xercesc::DOMAttr&        reference;
  typedef const xercesc::DOMAttr&  const_reference;

  typedef <implementation-defined> iterator;
  typedef <implementation-defined> const_iterator;
  typedef <implementation-defined> reverse_iterator;
  typedef <implementation-defined> const_reverse_iterator;

  typedef <implementation-defined> size_type;
  typedef <implementation-defined> difference_type;
  typedef <implementation-defined> allocator_type;

public:
  attribute_set \201xercesc::DOMDocument&\202;

  template <typename I>
  attribute_set \201const I& begin, const I& end, xercesc::DOMDocument&\202;

  attribute_set \201const attribute_set&, xercesc::DOMDocument&\202;

  attribute_set&
  operator= \201const attribute_set&\202;

public:)WR(
  const_iterator
  begin \201\202 const;

  const_iterator
  end \201\202 const;

  iterator
  begin \201\202;

  iterator
  end \201\202;

  const_reverse_iterator
  rbegin \201\202 const;

  const_reverse_iterator
  rend \201\202 const;

  reverse_iterator
  rbegin \201\202;

  reverse_iterator
  rend \201\202;

public:
  size_type
  size \201\202 const;

  size_type
  max_size \201\202 const;)WR(

  bool
  empty \201\202 const;

  void
  clear \201\202;

public:
  // Makes a deep copy.
  //
  std::pair<iterator, bool>
  insert \201const xercesc::DOMAttr&\202;

  // Assumes ownership.
  //
  std::pair<iterator, bool>
  insert \201xercesc::DOMAttr*\202;

  // Makes a deep copy.
  //
  iterator
  insert \201iterator position, const xercesc::DOMAttr&\202;

  // Assumes ownership.
  //
  iterator
  insert \201iterator position, xercesc::DOMAttr*\202;

  template <typename I>
  void)WR(
  insert \201const I& begin, const I& end\202;

public:
  void
  erase \201iterator position\202;

  size_type
  erase \201const std::basic_string<C>& name\202;

  size_type
  erase \201const std::basic_string<C>& namespace_,
         const std::basic_string<C>& name\202;

  size_type
  erase \201const XMLCh* name\202;

  size_type
  erase \201const XMLCh* namespace_, const XMLCh* name\202;

  void
  erase \201iterator begin, iterator end\202;

public:
  size_type
  count \201const std::basic_string<C>& name\202 const;

  size_type
  count \201const std::basic_string<C>& namespace_,
         const std::basic_string<C>& name\202 const;
)WR(
  size_type
  count \201const XMLCh* name\202 const;

  size_type
  count \201const XMLCh* namespace_, const XMLCh* name\202 const;

  iterator
  find \201const std::basic_string<C>& name\202;

  iterator
  find \201const std::basic_string<C>& namespace_,
        const std::basic_string<C>& name\202;

  iterator
  find \201const XMLCh* name\202;

  iterator
  find \201const XMLCh* namespace_, const XMLCh* name\202;

  const_iterator
  find \201const std::basic_string<C>& name\202 const;

  const_iterator
  find \201const std::basic_string<C>& namespace_,
        const std::basic_string<C>& name\202 const;

  const_iterator
  find \201const XMLCh* name\202 const;

  const_iterator)WR(
  find \201const XMLCh* namespace_, const XMLCh* name\202 const;

public:
  // Note that the DOMDocument object of the two sets being
  // swapped should be the same.
  //
  void
  swap \201attribute_set&\202;
};

bool
operator== \201const attribute_set&, const attribute_set&\202;

bool
operator!= \201const attribute_set&, const attribute_set&\202;)RP(

  )0 P(The follow)HY(ing)YH( code shows how one could use this mapping:)EP(

  ) 25 73 PR(void
f \201object& o, const xercesc::DOMAttr& a\202
{
  using namespace xercesc;

  object::any_attribute_set& s \201o.any_attribute \201\202\202;

  // Iteration.
  //
  for \201object::any_attribute_iterator i \201s.begin \201\202\202; i != s.end \201\202; ++i\202
  {
    DOMAttr& a \201*i\202;
  }

  // Modification.
  //
  s.insert \201a\202;                         // deep copy
  DOMDocument& doc \201o.dom_document \201\202\202;
  s.insert \201doc.createAttribute \201...\202\202; // assumes ownership

  // Searching.
  //
  object::any_attribute_iterator i \201s.find \201"name"\202\202;
  i = s.find \201"http://www.w3.org/XML/1998/namespace", "lang"\202;
})RP(

  

  )0 2 59 H(2.13)WB 156 Sn()WB 63 Sn( Mapping for Mixed Content Models)EA()EH(

  )0 P(For XML Schema types with mixed content models C++/Tree provides
     mapping support only if the type is marked as ordered
     \201)0 51 1 A(Section 2.8.4, "Element Order")51 0 TN TL()Ec /AF f D(\202. Use the
     )SM(--ordered-type-mixed)ES( XSD compiler option to
     auto)HY(mat)HY(i)HY(cally)YH( mark all types with mixed content as ordered.)EP(

  )0 P(For an ordered type with mixed content, C++/Tree adds an extra
     text content sequence that is used to store the text frag)HY(ments)YH(.
     This text content sequence is also assigned the content id and
     its entries are included in the content order sequence, just
     like elements. As a result, it is possi)HY(ble)YH( to capture the order
     between elements and text frag)HY(ments)YH(.)EP(

  )0 P(As an example, consider the follow)HY(ing)YH( schema that describes text
     with embed)HY(ded)YH( links:)EP(

  ) 13 73 PR(<complexType name="anchor">
  <simpleContent>
    <extension base="string">
      <attribute name="href" type="anyURI" use="required"/>
    </extension>
  </simpleContent>
</complexType>

<complexType name="text" mixed="true">
  <sequence>
    <element name="a" type="anchor" minOccurs="0" maxOccurs="unbounded"/>
  </sequence>
</complexType>)RP(

  )0 P(The gener)HY(ated)YH( )SM(text)ES( C++ class will provide the follow)HY(ing)YH(
     API \201assum)HY(ing)YH( it is marked as ordered\202:)EP(

  ) 57 78 PR(class text: public xml_schema::type
{
public:
  // a
  //
  typedef anchor a_type;
  typedef sequence<a_type> a_sequence;
  typedef a_sequence::iterator a_iterator;
  typedef a_sequence::const_iterator a_const_iterator;

  static const std::size_t a_id = 1UL;

  const a_sequence&
  a \201\202 const;

  a_sequence&
  a \201\202;

  void
  a \201const a_sequence&\202;

  // text_content
  //
  typedef xml_schema::string text_content_type;
  typedef sequence<text_content_type> text_content_sequence;
  typedef text_content_sequence::iterator text_content_iterator;
  typedef text_content_sequence::const_iterator text_content_const_iterator;

  static const std::size_t text_content_id = 2UL;

  const text_content_sequence&)WR(
  text_content \201\202 const;

  text_content_sequence&
  text_content \201\202;

  void
  text_content \201const text_content_sequence&\202;

  // content_order
  //
  typedef xml_schema::content_order content_order_type;
  typedef std::vector<content_order_type> content_order_sequence;
  typedef content_order_sequence::iterator content_order_iterator;
  typedef content_order_sequence::const_iterator content_order_const_iterator;

  const content_order_sequence&
  content_order \201\202 const;

  content_order_sequence&
  content_order \201\202;

  void
  content_order \201const content_order_sequence&\202;

  ...
};)RP(

  )0 P(Given this inter)HY(face)YH( we can iterate over both link elements
     and text in content order. The follow)HY(ing)YH( code frag)HY(ment)YH( converts
     our format to plain text with refer)HY(ences)YH(.)EP(

  ) 26 72 PR(const text& t = ...

for \201text::content_order_const_iterator i \201t.content_order \201\202.begin \201\202\202;
     i != t.content_order \201\202.end \201\202;
     ++i\202
{
  switch \201i->id\202
  {
  case text::a_id:
    {
      const anchor& a \201t.a \201\202[i->index]\202;
      cerr << a << "[" << a.href \201\202 << "]";
      break;
    }
  case text::text_content_id:
    {
      const xml_schema::string& s \201t.text_content \201\202[i->index]\202;
      cerr << s;
      break;
    }
  default:
    {
      assert \201false\202; // Unknown content id.
    }
  }
})RP(

  )0 P(For the complete working code that shows the use of mixed content
     in ordered types refer to the )SM(order/mixed)ES( example in
     the )SM(exam)HY(ples)YH(/cxx/tree/)ES( direc)HY(tory)YH( in the XSD
     distri)HY(bu)HY(tion)YH(.)EP(

  


  )0 1 60 H(3)WB 157 Sn()WB 64 Sn( Parsing)EA()EH(

  )0 P(This chapter covers various aspects of parsing XML instance
     docu)HY(ments)YH( in order to obtain corre)HY(spond)HY(ing)YH( tree-like object
     model.
  )EP(

  )0 P(Each global XML Schema element in the form:)EP(

  ) 1 34 PR(<element name="name" type="type"/>)RP(

  )0 P(is mapped to 14 over)HY(loaded)YH( C++ func)HY(tions)YH( in the form:)EP(

  ) 96 65 PR(// Read from a URI or a local file.
//

std::[auto|unique]_ptr<type>
name \201const std::basic_string<C>& uri,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201const std::basic_string<C>& uri,
      xml_schema::error_handler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201const std::basic_string<C>& uri,
      xercesc::DOMErrorHandler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;


// Read from std::istream.
//

std::[auto|unique]_ptr<type>
name \201std::istream&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201std::istream&,)WR(
      xml_schema::error_handler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201std::istream&,
      xercesc::DOMErrorHandler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;


std::[auto|unique]_ptr<type>
name \201std::istream&,
      const std::basic_string<C>& id,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201std::istream&,
      const std::basic_string<C>& id,
      xml_schema::error_handler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201std::istream&,
      const std::basic_string<C>& id,
      xercesc::DOMErrorHandler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;)WR(


// Read from InputSource.
//

std::[auto|unique]_ptr<type>
name \201xercesc::InputSource&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201xercesc::InputSource&,
      xml_schema::error_handler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;

std::[auto|unique]_ptr<type>
name \201xercesc::InputSource&,
      xercesc::DOMErrorHandler&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;


// Read from DOM.
//

std::[auto|unique]_ptr<type>
name \201const xercesc::DOMDocument&,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;)WR(

std::[auto|unique]_ptr<type>
name \201xml_schema::dom::[auto|unique]_ptr<xercesc::DOMDocument>,
      xml_schema::flags = 0,
      const xml_schema::properties& = xml_schema::properties \201\202\202;)RP(

  )0 P(You can choose between reading an XML instance from a local file,
     URI, )SM(std::istream)ES(, )SM(xercesc::Input)HY(Source)YH()ES(,
     or a pre-parsed DOM instance in the form of
     )SM(xercesc::DOMDoc)HY(u)HY(ment)YH()ES(. All the parsing func)HY(tions)YH(
     return a dynam)HY(i)HY(cally)YH( allo)HY(cated)YH( object model as either
     )SM(std::auto_ptr)ES( or )SM(std::unique_ptr)ES(,
     depend)HY(ing)YH( on the C++ stan)HY(dard)YH( selected. Each of these parsing
     func)HY(tions)YH( is discussed in more detail in the follow)HY(ing)YH( sections.
  )EP(

  )0 2 61 H(3.1)WB 158 Sn()WB 65 Sn( Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime)EA()EH(

  )0 P(Some parsing func)HY(tions)YH( expect you to initial)HY(ize)YH( the Xerces-C++
     runtime while others initial)HY(ize)YH( and termi)HY(nate)YH( it as part of their
     work. The general rule is as follows: if a func)HY(tion)YH( has any argu)HY(ments)YH(
     or return a value that is an instance of a Xerces-C++ type, then
     this func)HY(tion)YH( expects you to initial)HY(ize)YH( the Xerces-C++ runtime.
     Other)HY(wise)YH(, the func)HY(tion)YH( initial)HY(izes)YH( and termi)HY(nates)YH( the runtime for
     you. Note that it is legal to have nested calls to the Xerces-C++
     initial)HY(ize)YH( and termi)HY(nate)YH( func)HY(tions)YH( as long as the calls are balanced.
  )EP(

  )0 P(You can instruct parsing func)HY(tions)YH( that initial)HY(ize)YH( and termi)HY(nate)YH(
     the runtime not to do so by passing the
     )SM(xml_schema::flags::dont_initial)HY(ize)YH()ES( flag \201see
     )0 66 1 A(Section 3.2, "Flags and Prop)HY(er)HY(ties)YH(")66 0 TN TL()Ec /AF f D(\202.
  )EP(


  )0 2 62 H(3.2)WB 159 Sn()WB 66 Sn( Flags and Prop)HY(er)HY(ties)YH()EA()EH(

  )0 P(Parsing flags and prop)HY(er)HY(ties)YH( are the last two argu)HY(ments)YH( of every
     parsing func)HY(tion)YH(. They allow you to fine-tune the process of
     instance vali)HY(da)HY(tion)YH( and parsing. Both argu)HY(ments)YH( are optional.
  )EP(


  )0 P(The follow)HY(ing)YH( flags are recog)HY(nized)YH( by the parsing func)HY(tions)YH(:)EP(

  )0 DL(    )0 DT()SM(xml_schema::flags::keep_dom)ES(
    )DD(Keep asso)HY(ci)HY(a)HY(tion)YH( between DOM nodes and the result)HY(ing)YH(
        object model nodes. For more infor)HY(ma)HY(tion)YH( about DOM asso)HY(ci)HY(a)HY(tion)YH(
        refer to )0 93 1 A(Section 5.1, "DOM Asso)HY(ci)HY(a)HY(tion)YH(")93 0 TN TL()Ec /AF f D(.

    )0 DT()SM(xml_schema::flags::own_dom)ES(
    )DD(Assume owner)HY(ship)YH( of the DOM docu)HY(ment)YH( passed. This flag only
        makes sense together with the )SM(keep_dom)ES( flag in
        the call to the parsing func)HY(tion)YH( with the
        )SM(xml_schema::dom::[auto|unique]_ptr<DOMDoc)HY(u)HY(ment)YH(>)ES(
        argu)HY(ment)YH(.

    )0 DT()SM(xml_schema::flags::dont_vali)HY(date)YH()ES(
    )DD(Do not vali)HY(date)YH( instance docu)HY(ments)YH( against schemas.

    )0 DT()SM(xml_schema::flags::dont_initial)HY(ize)YH()ES(
    )DD(Do not initial)HY(ize)YH( the Xerces-C++ runtime.
  )LD(

  )0 P(You can pass several flags by combin)HY(ing)YH( them using the bit-wise OR
     oper)HY(a)HY(tor)YH(. For example:)EP(

  ) 4 61 PR(using xml_schema::flags;

std::auto_ptr<type> r \201
  name \201"test.xml", flags::keep_dom | flags::dont_validate\202\202;)RP(

  )0 P(By default, vali)HY(da)HY(tion)YH( of instance docu)HY(ments)YH( is turned on even
     though parsers gener)HY(ated)YH( by XSD do not assume instance
     docu)HY(ments)YH( are valid. They include a number of checks that prevent
     construc)HY(tion)YH( of incon)HY(sis)HY(tent)YH( object models. This,
     however, does not mean that an instance docu)HY(ment)YH( that was
     success)HY(fully)YH( parsed by the XSD-gener)HY(ated)YH( parsers is
     valid per the corre)HY(spond)HY(ing)YH( schema. If an instance docu)HY(ment)YH( is not
     "valid enough" for the gener)HY(ated)YH( parsers to construct consis)HY(tent)YH(
     object model, one of the excep)HY(tions)YH( defined in
     )SM(xml_schema)ES( names)HY(pace)YH( is thrown \201see
     )0 67 1 A(Section 3.3, "Error Handling")67 0 TN TL()Ec /AF f D(\202.
  )EP(

  )0 P(For more infor)HY(ma)HY(tion)YH( on the Xerces-C++ runtime initial)HY(iza)HY(tion)YH(
     refer to )0 65 1 A(Section 3.1, "Initial)HY(iz)HY(ing)YH( the Xerces-C++
     Runtime")65 0 TN TL()Ec /AF f D(.
  )EP(

  )0 P(The )SM(xml_schema::prop)HY(er)HY(ties)YH()ES( class allows you to
     program)HY(mat)HY(i)HY(cally)YH( specify schema loca)HY(tions)YH( to be used instead
     of those spec)HY(i)HY(fied)YH( with the )SM(xsi::schemaLo)HY(ca)HY(tion)YH()ES(
     and )SM(xsi::noNames)HY(paceSchemaLo)HY(ca)HY(tion)YH()ES( attributes
     in instance docu)HY(ments)YH(. The inter)HY(face)YH( of the )SM(prop)HY(er)HY(ties)YH()ES(
     class is presented below:
  )EP(

  ) 9 70 PR(class properties
{
public:
  void
  schema_location \201const std::basic_string<C>& namespace_,
                   const std::basic_string<C>& location\202;
  void
  no_namespace_schema_location \201const std::basic_string<C>& location\202;
};)RP(

  )0 P(Note that all loca)HY(tions)YH( are rela)HY(tive)YH( to an instance docu)HY(ment)YH( unless
     they are URIs. For example, if you want to use a local file as your
     schema, then you will need to pass
     )SM(file:///abso)HY(lute)YH(/path/to/your/schema)ES( as the loca)HY(tion)YH(
     argu)HY(ment)YH(.
  )EP(

  )0 2 63 H(3.3)WB 160 Sn()WB 67 Sn( Error Handling)EA()EH(

  )0 P(As discussed in )0 14 1 A(Section 2.2, "Error Handling")14 0 TN TL()Ec /AF f D(,
     the mapping uses the C++ excep)HY(tion)YH( handling mech)HY(a)HY(nism)YH( as its primary
     way of report)HY(ing)YH( error condi)HY(tions)YH(. However, to handle recov)HY(er)HY(able)YH(
     parsing and vali)HY(da)HY(tion)YH( errors and warn)HY(ings)YH(, a call)HY(back)YH( inter)HY(face)YH( maybe
     preferred by the appli)HY(ca)HY(tion)YH(.)EP(

  )0 P(To better under)HY(stand)YH( error handling and report)HY(ing)YH( strate)HY(gies)YH( employed
     by the parsing func)HY(tions)YH(, it is useful to know that the
     trans)HY(for)HY(ma)HY(tion)YH( of an XML instance docu)HY(ment)YH( to a stat)HY(i)HY(cally)YH(-typed
     tree happens in two stages. The first stage, performed by Xerces-C++,
     consists of parsing an XML docu)HY(ment)YH( into a DOM instance. For short,
     we will call this stage the XML-DOM stage. Vali)HY(da)HY(tion)YH(, if not disabled,
     happens during this stage. The second stage,
     performed by the gener)HY(ated)YH( parsers, consist of parsing the DOM
     instance into the stat)HY(i)HY(cally)YH(-typed tree. We will call this stage
     the DOM-Tree stage. Addi)HY(tional)YH( checks are performed during this
     stage in order to prevent construc)HY(tion)YH( of incon)HY(sis)HY(tent)YH( tree which
     could other)HY(wise)YH( happen when vali)HY(da)HY(tion)YH( is disabled, for example.)EP(

  )0 P(All parsing func)HY(tions)YH( except the one that oper)HY(ates)YH( on a DOM instance
     come in over)HY(loaded)YH( triples. The first func)HY(tion)YH( in such a triple
     reports error condi)HY(tions)YH( exclu)HY(sively)YH( by throw)HY(ing)YH( excep)HY(tions)YH(. It
     accu)HY(mu)HY(lates)YH( all the parsing and vali)HY(da)HY(tion)YH( errors of the XML-DOM
     stage and throws them in a single instance of the
     )SM(xml_schema::parsing)ES( excep)HY(tion)YH( \201described below\202.
     The second and the third func)HY(tions)YH( in the triple use call)HY(back)YH(
     inter)HY(faces)YH( to report parsing and vali)HY(da)HY(tion)YH( errors and warn)HY(ings)YH(.
     The two call)HY(back)YH( inter)HY(faces)YH( are )SM(xml_schema::error_handler)ES(
     and )SM(xercesc::DOMEr)HY(rorHan)HY(dler)YH()ES(. For more infor)HY(ma)HY(tion)YH(
     on the )SM(xercesc::DOMEr)HY(rorHan)HY(dler)YH()ES( inter)HY(face)YH( refer to
     the Xerces-C++ docu)HY(men)HY(ta)HY(tion)YH(. The )SM(xml_schema::error_handler)ES(
     inter)HY(face)YH( is presented below:
  )EP(

  ) 23 51 PR(class error_handler
{
public:
  struct severity
  {
    enum value
    {
      warning,
      error,
      fatal
    };
  };

  virtual bool
  handle \201const std::basic_string<C>& id,
          unsigned long line,
          unsigned long column,
          severity,
          const std::basic_string<C>& message\202 = 0;

  virtual
  ~error_handler \201\202;
};)RP(

  )0 P(The )SM(id)ES( argu)HY(ment)YH( of the )SM(error_handler::handle)ES(
     func)HY(tion)YH( iden)HY(ti)HY(fies)YH( the resource being parsed \201e.g., a file name or
     URI\202.
  )EP(

  )0 P(By return)HY(ing)YH( )SM(true)ES( from the )SM(handle)ES( func)HY(tion)YH(
     you instruct the parser to recover and continue parsing. Return)HY(ing)YH(
     )SM(false)ES( results in termi)HY(na)HY(tion)YH( of the parsing process.
     An error with the )SM(fatal)ES( sever)HY(ity)YH( level results in
     termi)HY(na)HY(tion)YH( of the parsing process no matter what is returned from
     the )SM(handle)ES( func)HY(tion)YH(. It is safe to throw an excep)HY(tion)YH(
     from the )SM(handle)ES( func)HY(tion)YH(.
  )EP(

  )0 P(The DOM-Tree stage reports error condi)HY(tions)YH( exclu)HY(sively)YH( by throw)HY(ing)YH(
     excep)HY(tions)YH(. Indi)HY(vid)HY(ual)YH( excep)HY(tions)YH( thrown by the parsing func)HY(tions)YH(
     are described in the follow)HY(ing)YH( sub-sections.
  )EP(


  )0 3 64 H(3.3.1)WB 161 Sn()WB 68 Sn( )SM(xml_schema::parsing)ES()EA()EH(

  ) 57 56 PR(struct severity
{
  enum value
  {
    warning,
    error
  };

  severity \201value\202;
  operator value \201\202 const;
};

struct error
{
  error \201severity,
         const std::basic_string<C>& id,
         unsigned long line,
         unsigned long column,
         const std::basic_string<C>& message\202;

  severity
  severity \201\202 const;

  const std::basic_string<C>&
  id \201\202 const;

  unsigned long
  line \201\202 const;

  unsigned long
  column \201\202 const;)WR(

  const std::basic_string<C>&
  message \201\202 const;
};

std::basic_ostream<C>&
operator<< \201std::basic_ostream<C>&, const error&\202;

struct diagnostics: std::vector<error>
{
};

std::basic_ostream<C>&
operator<< \201std::basic_ostream<C>&, const diagnostics&\202;

struct parsing: virtual exception
{
  parsing \201\202;
  parsing \201const diagnostics&\202;

  const diagnostics&
  diagnostics \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::parsing)ES( excep)HY(tion)YH( is thrown if there
     were parsing or vali)HY(da)HY(tion)YH( errors reported during the XML-DOM stage.
     If no call)HY(back)YH( inter)HY(face)YH( was provided to the parsing func)HY(tion)YH(, the
     excep)HY(tion)YH( contains a list of errors and warn)HY(ings)YH( acces)HY(si)HY(ble)YH( using
     the )SM(diag)HY(nos)HY(tics)YH()ES( func)HY(tion)YH(. The usual condi)HY(tions)YH( when
     this excep)HY(tion)YH( is thrown include malformed XML instances and, if
     vali)HY(da)HY(tion)YH( is turned on, invalid instance docu)HY(ments)YH(.
  )EP(

  )0 3 65 H(3.3.2)WB 162 Sn()WB 69 Sn( )SM(xml_schema::expected_element)ES()EA()EH(

  ) 16 60 PR(struct expected_element: virtual exception
{
  expected_element \201const std::basic_string<C>& name,
                    const std::basic_string<C>& namespace_\202;


  const std::basic_string<C>&
  name \201\202 const;

  const std::basic_string<C>&
  namespace_ \201\202 const;


  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::expected_element)ES( excep)HY(tion)YH( is thrown
     when an expected element is not encoun)HY(tered)YH( by the DOM-Tree stage.
     The name and names)HY(pace)YH( of the expected element can be obtained using
     the )SM(name)ES( and )SM(names)HY(pace)YH(_)ES( func)HY(tions)YH( respec)HY(tively)YH(.
  )EP(


  )0 3 66 H(3.3.3)WB 163 Sn()WB 70 Sn( )SM(xml_schema::unex)HY(pected)YH(_element)ES()EA()EH(

  ) 25 72 PR(struct unexpected_element: virtual exception
{
  unexpected_element \201const std::basic_string<C>& encountered_name,
                      const std::basic_string<C>& encountered_namespace,
                      const std::basic_string<C>& expected_name,
                      const std::basic_string<C>& expected_namespace\202


  const std::basic_string<C>&
  encountered_name \201\202 const;

  const std::basic_string<C>&
  encountered_namespace \201\202 const;


  const std::basic_string<C>&
  expected_name \201\202 const;

  const std::basic_string<C>&
  expected_namespace \201\202 const;


  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::unex)HY(pected)YH(_element)ES( excep)HY(tion)YH( is thrown
     when an unex)HY(pected)YH( element is encoun)HY(tered)YH( by the DOM-Tree stage.
     The name and names)HY(pace)YH( of the encoun)HY(tered)YH( element can be obtained
     using the )SM(encoun)HY(tered)YH(_name)ES( and
     )SM(encoun)HY(tered)YH(_names)HY(pace)YH()ES( func)HY(tions)YH( respec)HY(tively)YH(. If an
     element was expected instead of the encoun)HY(tered)YH( one, its name
     and names)HY(pace)YH( can be obtained using the )SM(expected_name)ES( and
     )SM(expected_names)HY(pace)YH()ES( func)HY(tions)YH( respec)HY(tively)YH(. Other)HY(wise)YH(
     these func)HY(tions)YH( return empty strings.
  )EP(

  )0 3 67 H(3.3.4)WB 164 Sn()WB 71 Sn( )SM(xml_schema::expected_attribute)ES()EA()EH(

  ) 16 62 PR(struct expected_attribute: virtual exception
{
  expected_attribute \201const std::basic_string<C>& name,
                      const std::basic_string<C>& namespace_\202;


  const std::basic_string<C>&
  name \201\202 const;

  const std::basic_string<C>&
  namespace_ \201\202 const;


  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::expected_attribute)ES( excep)HY(tion)YH( is thrown
     when an expected attribute is not encoun)HY(tered)YH( by the DOM-Tree stage.
     The name and names)HY(pace)YH( of the expected attribute can be obtained using
     the )SM(name)ES( and )SM(names)HY(pace)YH(_)ES( func)HY(tions)YH( respec)HY(tively)YH(.
  )EP(


  )0 3 68 H(3.3.5)WB 165 Sn()WB 72 Sn( )SM(xml_schema::unex)HY(pected)YH(_enumer)HY(a)HY(tor)YH()ES()EA()EH(

  ) 10 65 PR(struct unexpected_enumerator: virtual exception
{
  unexpected_enumerator \201const std::basic_string<C>& enumerator\202;

  const std::basic_string<C>&
  enumerator \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::unex)HY(pected)YH(_enumer)HY(a)HY(tor)YH()ES( excep)HY(tion)YH( is thrown
     when an unex)HY(pected)YH( enumer)HY(a)HY(tor)YH( is encoun)HY(tered)YH( by the DOM-Tree stage.
     The enumer)HY(a)HY(tor)YH( can be obtained using the )SM(enumer)HY(a)HY(tor)YH()ES(
     func)HY(tions)YH(.
  )EP(

  )0 3 69 H(3.3.6)WB 166 Sn()WB 73 Sn( )SM(xml_schema::expected_text_content)ES()EA()EH(

  ) 5 47 PR(struct expected_text_content: virtual exception
{
  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::expected_text_content)ES( excep)HY(tion)YH( is thrown
     when a content other than text is encoun)HY(tered)YH( and the text content was
     expected by the DOM-Tree stage.
  )EP(

  )0 3 70 H(3.3.7)WB 167 Sn()WB 74 Sn( )SM(xml_schema::no_type_info)ES()EA()EH(

  ) 14 60 PR(struct no_type_info: virtual exception
{
  no_type_info \201const std::basic_string<C>& type_name,
                const std::basic_string<C>& type_namespace\202;

  const std::basic_string<C>&
  type_name \201\202 const;

  const std::basic_string<C>&
  type_namespace \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::no_type_info)ES( excep)HY(tion)YH( is thrown
     when there is no type infor)HY(ma)HY(tion)YH( asso)HY(ci)HY(ated)YH( with a type spec)HY(i)HY(fied)YH(
     by the )SM(xsi:type)ES( attribute. This excep)HY(tion)YH( is thrown
     by the DOM-Tree stage. The name and names)HY(pace)YH( of the type in ques)HY(tion)YH(
     can be obtained using the )SM(type_name)ES( and
     )SM(type_names)HY(pace)YH()ES( func)HY(tions)YH( respec)HY(tively)YH(. Usually, catch)HY(ing)YH(
     this excep)HY(tion)YH( means that you haven't linked the code gener)HY(ated)YH(
     from the schema defin)HY(ing)YH( the type in ques)HY(tion)YH( with your appli)HY(ca)HY(tion)YH(
     or this schema has been compiled without the
     )SM(--gener)HY(ate)YH(-poly)HY(mor)HY(phic)YH()ES( option.
  )EP(


  )0 3 71 H(3.3.8)WB 168 Sn()WB 75 Sn( )SM(xml_schema::not_derived)ES()EA()EH(

  ) 23 67 PR(struct not_derived: virtual exception
{
  not_derived \201const std::basic_string<C>& base_type_name,
               const std::basic_string<C>& base_type_namespace,
               const std::basic_string<C>& derived_type_name,
               const std::basic_string<C>& derived_type_namespace\202;

  const std::basic_string<C>&
  base_type_name \201\202 const;

  const std::basic_string<C>&
  base_type_namespace \201\202 const;


  const std::basic_string<C>&
  derived_type_name \201\202 const;

  const std::basic_string<C>&
  derived_type_namespace \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::not_derived)ES( excep)HY(tion)YH( is thrown
     when a type spec)HY(i)HY(fied)YH( by the )SM(xsi:type)ES( attribute is
     not derived from the expected base type. This excep)HY(tion)YH( is thrown
     by the DOM-Tree stage. The name and names)HY(pace)YH( of the expected
     base type can be obtained using the )SM(base_type_name)ES( and
     )SM(base_type_names)HY(pace)YH()ES( func)HY(tions)YH( respec)HY(tively)YH(. The name
     and names)HY(pace)YH( of the offend)HY(ing)YH( type can be obtained using the
     )SM(derived_type_name)ES( and
     )SM(derived_type_names)HY(pace)YH()ES( func)HY(tions)YH( respec)HY(tively)YH(.
  )EP(

  )0 3 72 H(3.3.9)WB 169 Sn()WB 76 Sn( )SM(xml_schema::no_prefix_mapping)ES()EA()EH(

  ) 10 57 PR(struct no_prefix_mapping: virtual exception
{
  no_prefix_mapping \201const std::basic_string<C>& prefix\202;

  const std::basic_string<C>&
  prefix \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::no_prefix_mapping)ES( excep)HY(tion)YH( is thrown
     during the DOM-Tree stage if a names)HY(pace)YH( prefix is encoun)HY(tered)YH( for
     which a prefix-names)HY(pace)YH( mapping hasn't been provided. The names)HY(pace)YH(
     prefix in ques)HY(tion)YH( can be obtained using the )SM(prefix)ES(
     func)HY(tion)YH(.
  )EP(

  )0 2 73 H(3.4)WB 170 Sn()WB 77 Sn( Reading from a Local File or URI)EA()EH(

  )0 P(Using a local file or URI is the simplest way to parse an XML instance.
     For example:)EP(

  ) 4 67 PR(using std::auto_ptr;

auto_ptr<type> r1 \201name \201"test.xml"\202\202;
auto_ptr<type> r2 \201name \201"http://www.codesynthesis.com/test.xml"\202\202;)RP(

  )0 P(Or, in the C++11 mode:)EP(

  ) 4 69 PR(using std::unique_ptr;

unique_ptr<type> r1 \201name \201"test.xml"\202\202;
unique_ptr<type> r2 \201name \201"http://www.codesynthesis.com/test.xml"\202\202;)RP(

  )0 2 74 H(3.5)WB 171 Sn()WB 78 Sn( Reading from )SM(std::istream)ES()EA()EH(

  )0 P(When using an )SM(std::istream)ES( instance, you may also
     pass an optional resource id. This id is used to iden)HY(tify)YH( the
     resource \201for example in error messages\202 as well as to resolve
     rela)HY(tive)YH( paths. For instance:)EP(

  ) 12 48 PR(using std::auto_ptr;

{
  std::ifstream ifs \201"test.xml"\202;
  auto_ptr<type> r \201name \201ifs, "test.xml"\202\202;
}

{
  std::string str \201"..."\202; // Some XML fragment.
  std::istringstream iss \201str\202;
  auto_ptr<type> r \201name \201iss\202\202;
})RP(

  )0 2 75 H(3.6)WB 172 Sn()WB 79 Sn( Reading from )SM(xercesc::Input)HY(Source)YH()ES()EA()EH(

  )0 P(Reading from a )SM(xercesc::Input)HY(Source)YH()ES( instance
     is similar to the )SM(std::istream)ES( case except
     the resource id is main)HY(tained)YH( by the )SM(Input)HY(Source)YH()ES(
     object. For instance:)EP(

  ) 2 34 PR(xercesc::StdInInputSource is;
std::auto_ptr<type> r \201name \201is\202\202;)RP(

  )0 2 76 H(3.7)WB 173 Sn()WB 80 Sn( Reading from DOM)EA()EH(

  )0 P(Reading from a )SM(xercesc::DOMDoc)HY(u)HY(ment)YH()ES( instance allows
     you to setup a custom XML-DOM stage. Things like DOM
     parser reuse, schema pre-parsing, and schema caching can be achieved
     with this approach. For more infor)HY(ma)HY(tion)YH( on how to obtain DOM
     repre)HY(sen)HY(ta)HY(tion)YH( from an XML instance refer to the Xerces-C++
     docu)HY(men)HY(ta)HY(tion)YH(. In addi)HY(tion)YH(, the
     )R7 2 A(C++/Tree Mapping
     FAQ)EA( shows how to parse an XML instance to a Xerces-C++
     DOM docu)HY(ment)YH( using the XSD runtime util)HY(i)HY(ties)YH(.
  )EP(

  )0 P(The last parsing func)HY(tion)YH( is useful when you would like to perform
     your own XML-to-DOM parsing and as)HY(so)HY(ciate)YH( the result)HY(ing)YH( DOM docu)HY(ment)YH(
     with the object model nodes. The auto)HY(matic)YH( )SM(DOMDoc)HY(u)HY(ment)YH()ES(
     pointer is reset and the result)HY(ing)YH( object model assumes owner)HY(ship)YH(
     of the DOM docu)HY(ment)YH( passed. For example:)EP(

  ) 18 72 PR(// C++98 version.
//
xml_schema::dom::auto_ptr<xercesc::DOMDocument> doc = ...

std::auto_ptr<type> r \201
  name \201doc, xml_schema::flags::keep_dom | xml_schema::flags::own_dom\202\202;

// At this point doc is reset to 0.

// C++11 version.
//
xml_schema::dom::unique_ptr<xercesc::DOMDocument> doc = ...

std::unique_ptr<type> r \201
  name \201std::move \201doc\202,
        xml_schema::flags::keep_dom | xml_schema::flags::own_dom\202\202;

// At this point doc is reset to 0.)RP(

  )0 1 77 H(4)WB 174 Sn()WB 81 Sn( Seri)HY(al)HY(iza)HY(tion)YH()EA()EH(

  )0 P(This chapter covers various aspects of seri)HY(al)HY(iz)HY(ing)YH( a
     tree-like object model to DOM or XML.
     In this regard, seri)HY(al)HY(iza)HY(tion)YH( is compli)HY(men)HY(tary)YH( to the reverse
     process of parsing a DOM or XML instance into an object model
     which is discussed in )0 64 1 A(Chapter 3,
     "Parsing")64 0 TN TL()Ec /AF f D(. Note that the gener)HY(a)HY(tion)YH( of the seri)HY(al)HY(iza)HY(tion)YH( code
     is optional and should be explic)HY(itly)YH( requested with the
     )SM(--gener)HY(ate)YH(-seri)HY(al)HY(iza)HY(tion)YH()ES( option. See the
     )R8 2 A(XSD
     Compiler Command Line Manual)EA( for more infor)HY(ma)HY(tion)YH(.
  )EP(

  )0 P(Each global XML Schema element in the form:
  )EP(


  ) 1 38 PR(<xsd:element name="name" type="type"/>)RP(

  )0 P(is mapped to 8 over)HY(loaded)YH( C++ func)HY(tions)YH( in the form:)EP(

  ) 70 56 PR(// Serialize to std::ostream.
//
void
name \201std::ostream&,
      const type&,
      const xml_schema::namespace_fomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;

void
name \201std::ostream&,
      const type&,
      xml_schema::error_handler&,
      const xml_schema::namespace_infomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;

void
name \201std::ostream&,
      const type&,
      xercesc::DOMErrorHandler&,
      const xml_schema::namespace_infomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;


// Serialize to XMLFormatTarget.
//)WR(
void
name \201xercesc::XMLFormatTarget&,
      const type&,
      const xml_schema::namespace_infomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;

void
name \201xercesc::XMLFormatTarget&,
      const type&,
      xml_schema::error_handler&,
      const xml_schema::namespace_infomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;

void
name \201xercesc::XMLFormatTarget&,
      const type&,
      xercesc::DOMErrorHandler&,
      const xml_schema::namespace_infomap& =
        xml_schema::namespace_infomap \201\202,
      const std::basic_string<C>& encoding = "UTF-8",
      xml_schema::flags = 0\202;


// Serialize to DOM.
//
xml_schema::dom::[auto|unique]_ptr<xercesc::DOMDocument>)WR(
name \201const type&,
      const xml_schema::namespace_infomap&
        xml_schema::namespace_infomap \201\202,
      xml_schema::flags = 0\202;

void
name \201xercesc::DOMDocument&,
      const type&,
      xml_schema::flags = 0\202;)RP(

  )0 P(You can choose between writing XML to )SM(std::ostream)ES( or
     )SM(xercesc::XMLFor)HY(mat)HY(Tar)HY(get)YH()ES( and creat)HY(ing)YH( a DOM instance
     in the form of )SM(xercesc::DOMDoc)HY(u)HY(ment)YH()ES(. Seri)HY(al)HY(iza)HY(tion)YH(
     to )SM(ostream)ES( or )SM(XMLFor)HY(mat)HY(Tar)HY(get)YH()ES( requires a
     consid)HY(er)HY(ably)YH( less work while seri)HY(al)HY(iza)HY(tion)YH( to DOM provides
     for greater flex)HY(i)HY(bil)HY(ity)YH(. Each of these seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(
     is discussed in more detail in the follow)HY(ing)YH( sections.
  )EP(


  )0 2 78 H(4.1)WB 175 Sn()WB 82 Sn( Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime)EA()EH(

  )0 P(Some seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( expect you to initial)HY(ize)YH( the Xerces-C++
     runtime while others initial)HY(ize)YH( and termi)HY(nate)YH( it as part of their
     work. The general rule is as follows: if a func)HY(tion)YH( has any argu)HY(ments)YH(
     or return a value that is an instance of a Xerces-C++ type, then
     this func)HY(tion)YH( expects you to initial)HY(ize)YH( the Xerces-C++ runtime.
     Other)HY(wise)YH(, the func)HY(tion)YH( initial)HY(izes)YH( and termi)HY(nates)YH( the runtime for
     you. Note that it is legal to have nested calls to the Xerces-C++
     initial)HY(ize)YH( and termi)HY(nate)YH( func)HY(tions)YH( as long as the calls are balanced.
  )EP(

  )0 P(You can instruct seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( that initial)HY(ize)YH( and termi)HY(nate)YH(
     the runtime not to do so by passing the
     )SM(xml_schema::flags::dont_initial)HY(ize)YH()ES( flag \201see
     )0 84 1 A(Section 4.3, "Flags")84 0 TN TL()Ec /AF f D(\202.
  )EP(

  )0 2 79 H(4.2)WB 176 Sn()WB 83 Sn( Names)HY(pace)YH( Infomap and Char)HY(ac)HY(ter)YH( Encod)HY(ing)YH()EA()EH(

  )0 P(When a docu)HY(ment)YH( being seri)HY(al)HY(ized)YH( uses XML names)HY(paces)YH(, custom
     prefix-names)HY(pace)YH( asso)HY(ci)HY(a)HY(tions)YH( can to be estab)HY(lished)YH(. If custom
     prefix-names)HY(pace)YH( mapping is not provided then generic prefixes
     \201)SM(p1)ES(, )SM(p2)ES(, etc\202 are auto)HY(mat)HY(i)HY(cally)YH( assigned
     to names)HY(paces)YH( as needed. Also, if
     you would like the result)HY(ing)YH( instance docu)HY(ment)YH( to contain the
     )SM(schemaLo)HY(ca)HY(tion)YH()ES( or )SM(noNames)HY(paceSchemaLo)HY(ca)HY(tion)YH()ES(
     attributes, you will need to provide names)HY(pace)YH(-schema asso)HY(ci)HY(a)HY(tions)YH(.
     The )SM(xml_schema::names)HY(pace)YH(_infomap)ES( class is used
     to capture this infor)HY(ma)HY(tion)YH(:)EP(

  ) 16 63 PR(struct namespace_info
{
  namespace_info \201\202;
  namespace_info \201const std::basic_string<C>& name,
                  const std::basic_string<C>& schema\202;

  std::basic_string<C> name;
  std::basic_string<C> schema;
};

// Map of namespace prefix to namespace_info.
//
struct namespace_infomap: public std::map<std::basic_string<C>,
                                          namespace_info>
{
};)RP(

  )0 P(Consider the follow)HY(ing)YH( asso)HY(ci)HY(a)HY(tions)YH( as an example:)EP(

  ) 4 52 PR(xml_schema::namespace_infomap map;

map["t"].name = "http://www.codesynthesis.com/test";
map["t"].schema = "test.xsd";)RP(

  )0 P(This map, if passed to one of the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(,
     could result in the follow)HY(ing)YH( XML frag)HY(ment)YH(:)EP(

  ) 4 72 PR(<?xml version="1.0" ?>
<t:name xmlns:t="http://www.codesynthesis.com/test"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.codesynthesis.com/test test.xsd">)RP(

  )0 P(As you can see, the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tion)YH( auto)HY(mat)HY(i)HY(cally)YH( added names)HY(pace)YH(
     mapping for the )SM(xsi)ES( prefix. You can change this by
     provid)HY(ing)YH( your own prefix:)EP(

  ) 6 62 PR(xml_schema::namespace_infomap map;

map["xsn"].name = "http://www.w3.org/2001/XMLSchema-instance";

map["t"].name = "http://www.codesynthesis.com/test";
map["t"].schema = "test.xsd";)RP(

  )0 P(This could result in the follow)HY(ing)YH( XML frag)HY(ment)YH(:)EP(

  ) 4 72 PR(<?xml version="1.0" ?>
<t:name xmlns:t="http://www.codesynthesis.com/test"
        xmlns:xsn="http://www.w3.org/2001/XMLSchema-instance"
        xsn:schemaLocation="http://www.codesynthesis.com/test test.xsd">)RP(

  )0 P(To specify the loca)HY(tion)YH( of a schema without a names)HY(pace)YH( you can use
     an empty prefix as in the example below: )EP(

  ) 3 34 PR(xml_schema::namespace_infomap map;

map[""].schema = "test.xsd";)RP(

  )0 P(This would result in the follow)HY(ing)YH( XML frag)HY(ment)YH(:)EP(

  ) 3 59 PR(<?xml version="1.0" ?>
<name xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="test.xsd">)RP(

  )0 P(To make a partic)HY(u)HY(lar)YH( names)HY(pace)YH( default you can use an empty
     prefix, for example:)EP(

  ) 4 51 PR(xml_schema::namespace_infomap map;

map[""].name = "http://www.codesynthesis.com/test";
map[""].schema = "test.xsd";)RP(

  )0 P(This could result in the follow)HY(ing)YH( XML frag)HY(ment)YH(:)EP(

  ) 4 70 PR(<?xml version="1.0" ?>
<name xmlns="http://www.codesynthesis.com/test"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.codesynthesis.com/test test.xsd">)RP(


  )0 P(Another bit of infor)HY(ma)HY(tion)YH( that you can pass to the seri)HY(al)HY(iza)HY(tion)YH(
     func)HY(tions)YH( is the char)HY(ac)HY(ter)YH( encod)HY(ing)YH( method that you would like to use.
     Common values for this argu)HY(ment)YH( are )SM("US-ASCII")ES(,
     )SM("ISO8859-1")ES(, )SM("UTF-8")ES(,
     )SM("UTF-16BE")ES(, )SM("UTF-16LE")ES(,
     )SM("UCS-4BE")ES(, and )SM("UCS-4LE")ES(. The default
     encod)HY(ing)YH( is )SM("UTF-8")ES(. For more infor)HY(ma)HY(tion)YH( on
     encod)HY(ing)YH( methods see the
     ")R11 2 A(Char)HY(ac)HY(ter)YH(
     Encod)HY(ing)YH()EA(" article from Wikipedia.
  )EP(

  )0 2 80 H(4.3)WB 177 Sn()WB 84 Sn( Flags)EA()EH(

  )0 P(Seri)HY(al)HY(iza)HY(tion)YH( flags are the last argu)HY(ment)YH( of every seri)HY(al)HY(iza)HY(tion)YH(
     func)HY(tion)YH(. They allow you to fine-tune the process of seri)HY(al)HY(iza)HY(tion)YH(.
     The flags argu)HY(ment)YH( is optional.
  )EP(


  )0 P(The follow)HY(ing)YH( flags are recog)HY(nized)YH( by the seri)HY(al)HY(iza)HY(tion)YH(
     func)HY(tions)YH(:)EP(

  )0 DL(    )0 DT()SM(xml_schema::flags::dont_initial)HY(ize)YH()ES(
    )DD(Do not initial)HY(ize)YH( the Xerces-C++ runtime.

    )0 DT()SM(xml_schema::flags::dont_pretty_print)ES(
    )DD(Do not add extra spaces or new lines that make the result)HY(ing)YH( XML
        slightly bigger but easier to read.

    )0 DT()SM(xml_schema::flags::no_xml_decla)HY(ra)HY(tion)YH()ES(
    )DD(Do not write XML decla)HY(ra)HY(tion)YH( \201<?xml ... ?>\202.
  )LD(

  )0 P(You can pass several flags by combin)HY(ing)YH( them using the bit-wise OR
     oper)HY(a)HY(tor)YH(. For example:)EP(

  ) 9 45 PR(std::auto_ptr<type> r = ...
std::ofstream ofs \201"test.xml"\202;
xml_schema::namespace_infomap map;
name \201ofs,
      *r,
      map,
      "UTF-8",
      xml_schema::flags::no_xml_declaration |
      xml_schema::flags::dont_pretty_print\202;)RP(

  )0 P(For more infor)HY(ma)HY(tion)YH( on the Xerces-C++ runtime initial)HY(iza)HY(tion)YH(
     refer to )0 82 1 A(Section 4.1, "Initial)HY(iz)HY(ing)YH( the Xerces-C++
     Runtime")82 0 TN TL()Ec /AF f D(.
  )EP(

  )0 2 81 H(4.4)WB 178 Sn()WB 85 Sn( Error Handling)EA()EH(

  )0 P(As with the parsing func)HY(tions)YH( \201see )0 67 1 A(Section 3.3,
     "Error Handling")67 0 TN TL()Ec /AF f D(\202, to better under)HY(stand)YH( error handling and
     report)HY(ing)YH( strate)HY(gies)YH( employed by the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(, it
     is useful to know that the trans)HY(for)HY(ma)HY(tion)YH( of a stat)HY(i)HY(cally)YH(-typed
     tree to an XML instance docu)HY(ment)YH( happens in two stages. The first
     stage, performed by the gener)HY(ated)YH( code, consist of build)HY(ing)YH( a DOM
     instance from the stat)HY(i)HY(cally)YH(-typed tree . For short, we will call
     this stage the Tree-DOM stage. The second stage, performed by
     Xerces-C++, consists of seri)HY(al)HY(iz)HY(ing)YH( the DOM instance into the XML
     docu)HY(ment)YH(. We will call this stage the DOM-XML stage.
  )EP(

  )0 P(All seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( except the two that seri)HY(al)HY(ize)YH( into
     a DOM instance come in over)HY(loaded)YH( triples. The first func)HY(tion)YH(
     in such a triple reports error condi)HY(tions)YH( exclu)HY(sively)YH( by throw)HY(ing)YH(
     excep)HY(tions)YH(. It accu)HY(mu)HY(lates)YH( all the seri)HY(al)HY(iza)HY(tion)YH( errors of the
     DOM-XML stage and throws them in a single instance of the
     )SM(xml_schema::seri)HY(al)HY(iza)HY(tion)YH()ES( excep)HY(tion)YH( \201described below\202.
     The second and the third func)HY(tions)YH( in the triple use call)HY(back)YH(
     inter)HY(faces)YH( to report seri)HY(al)HY(iza)HY(tion)YH( errors and warn)HY(ings)YH(. The two
     call)HY(back)YH( inter)HY(faces)YH( are )SM(xml_schema::error_handler)ES( and
     )SM(xercesc::DOMEr)HY(rorHan)HY(dler)YH()ES(. The
     )SM(xml_schema::error_handler)ES( inter)HY(face)YH( is described in
     )0 67 1 A(Section 3.3, "Error Handling")67 0 TN TL()Ec /AF f D(. For more infor)HY(ma)HY(tion)YH(
     on the )SM(xercesc::DOMEr)HY(rorHan)HY(dler)YH()ES( inter)HY(face)YH( refer to the
     Xerces-C++ docu)HY(men)HY(ta)HY(tion)YH(.
  )EP(

  )0 P(The Tree-DOM stage reports error condi)HY(tions)YH( exclu)HY(sively)YH( by throw)HY(ing)YH(
     excep)HY(tions)YH(. Indi)HY(vid)HY(ual)YH( excep)HY(tions)YH( thrown by the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH(
     are described in the follow)HY(ing)YH( sub-sections.
  )EP(

  )0 3 82 H(4.4.1)WB 179 Sn()WB 86 Sn( )SM(xml_schema::seri)HY(al)HY(iza)HY(tion)YH()ES()EA()EH(

  ) 11 39 PR(struct serialization: virtual exception
{
  serialization \201\202;
  serialization \201const diagnostics&\202;

  const diagnostics&
  diagnostics \201\202 const;

  virtual const char*
  what \201\202 const throw \201\202;
};)RP(

  )0 P(The )SM(xml_schema::diag)HY(nos)HY(tics)YH()ES( class is described in
     )0 68 1 A(Section 3.3.1, ")SM(xml_schema::parsing)ES(")68 0 TN TL()Ec /AF f D(.
     The )SM(xml_schema::seri)HY(al)HY(iza)HY(tion)YH()ES( excep)HY(tion)YH( is thrown if
     there were seri)HY(al)HY(iza)HY(tion)YH( errors reported during the DOM-XML stage.
     If no call)HY(back)YH( inter)HY(face)YH( was provided to the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tion)YH(,
     the excep)HY(tion)YH( contains a list of errors and warn)HY(ings)YH( acces)HY(si)HY(ble)YH( using
     the )SM(diag)HY(nos)HY(tics)YH()ES( func)HY(tion)YH(.
  )EP(


  )0 3 83 H(4.4.2)WB 180 Sn()WB 87 Sn( )SM(xml_schema::unex)HY(pected)YH(_element)ES()EA()EH(

  )0 P(The )SM(xml_schema::unex)HY(pected)YH(_element)ES( excep)HY(tion)YH( is
     described in )0 70 1 A(Section 3.3.3,
     ")SM(xml_schema::unex)HY(pected)YH(_element)ES(")70 0 TN TL()Ec /AF f D(. It is thrown
     by the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( during the Tree-DOM stage if the
     root element name of the provided DOM instance does not match with
     the name of the element this seri)HY(al)HY(iza)HY(tion)YH( func)HY(tion)YH( is for.
  )EP(

  )0 3 84 H(4.4.3)WB 181 Sn()WB 88 Sn( )SM(xml_schema::no_type_info)ES()EA()EH(

  )0 P(The )SM(xml_schema::no_type_info)ES( excep)HY(tion)YH( is
     described in )0 74 1 A(Section 3.3.7,
     ")SM(xml_schema::no_type_info)ES(")74 0 TN TL()Ec /AF f D(. It is thrown
     by the seri)HY(al)HY(iza)HY(tion)YH( func)HY(tions)YH( during the Tree-DOM stage when there
     is no type infor)HY(ma)HY(tion)YH( asso)HY(ci)HY(ated)YH( with a dynamic type of an
     element. Usually, catch)HY(ing)YH( this excep)HY(tion)YH( means that you haven't
     linked the code gener)HY(ated)YH( from the schema defin)HY(ing)YH( the type in
     ques)HY(tion)YH( with your appli)HY(ca)HY(tion)YH( or this schema has been compiled
     without the )SM(--gener)HY(ate)YH(-poly)HY(mor)HY(phic)YH()ES( option.
  )EP(

  )0 2 85 H(4.5)WB 182 Sn()WB 89 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to )SM(std::ostream)ES()EA()EH(

  )0 P(In order to seri)HY(al)HY(ize)YH( to )SM(std::ostream)ES( you will need
     an object model, an output stream and, option)HY(ally)YH(, a names)HY(pace)YH(
     infomap. For instance:)EP(

  ) 14 61 PR(// Obtain the object model.
//
std::auto_ptr<type> r = ...

// Prepare namespace mapping and schema location information.
//
xml_schema::namespace_infomap map;

map["t"].name = "http://www.codesynthesis.com/test";
map["t"].schema = "test.xsd";

// Write it out.
//
name \201std::cout, *r, map\202;)RP(

  )0 P(Note that the output stream is treated as a binary stream. This
     becomes impor)HY(tant)YH( when you use a char)HY(ac)HY(ter)YH( encod)HY(ing)YH( that is wider
     than 8-bit )SM(char)ES(, for instance UTF-16 or UCS-4. For
     example, things will most likely break if you try to seri)HY(al)HY(ize)YH(
     to )SM(std::ostringstream)ES( with UTF-16 or UCS-4 as an
     encod)HY(ing)YH(. This is due to the special value,
     )SM('\2000')ES(, that will most likely occur as part of such
     seri)HY(al)HY(iza)HY(tion)YH( and it won't have the special meaning assumed by
     )SM(std::ostringstream)ES(.
  )EP(


  )0 2 86 H(4.6)WB 183 Sn()WB 90 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to )SM(xercesc::XMLFor)HY(mat)HY(Tar)HY(get)YH()ES()EA()EH(

  )0 P(Seri)HY(al)HY(iz)HY(ing)YH( to an )SM(xercesc::XMLFor)HY(mat)HY(Tar)HY(get)YH()ES( instance
     is similar the )SM(std::ostream)ES( case. For instance:
  )EP(

  ) 38 63 PR(using std::auto_ptr;

// Obtain the object model.
//
auto_ptr<type> r = ...

// Prepare namespace mapping and schema location information.
//
xml_schema::namespace_infomap map;

map["t"].name = "http://www.codesynthesis.com/test";
map["t"].schema = "test.xsd";

using namespace xercesc;

XMLPlatformUtils::Initialize \201\202;

{
  // Choose a target.
  //
  auto_ptr<XMLFormatTarget> ft;

  if \201argc != 2\202
  {
    ft = auto_ptr<XMLFormatTarget> \201new StdOutFormatTarget \201\202\202;
  }
  else
  {
    ft = auto_ptr<XMLFormatTarget> \201
      new LocalFileFormatTarget \201argv[1]\202\202;
  })WR(

  // Write it out.
  //
  name \201*ft, *r, map\202;
}

XMLPlatformUtils::Terminate \201\202;)RP(

  )0 P(Note that we had to initial)HY(ize)YH( the Xerces-C++ runtime before we
     could call this seri)HY(al)HY(iza)HY(tion)YH( func)HY(tion)YH(.)EP(

  )0 2 87 H(4.7)WB 184 Sn()WB 91 Sn( Seri)HY(al)HY(iz)HY(ing)YH( to DOM)EA()EH(

  )0 P(The mapping provides two over)HY(loaded)YH( func)HY(tions)YH( that imple)HY(ment)YH(
     seri)HY(al)HY(iza)HY(tion)YH( to a DOM instance. The first creates a DOM instance
     for you and the second seri)HY(al)HY(izes)YH( to an exist)HY(ing)YH( DOM instance.
     While seri)HY(al)HY(iz)HY(ing)YH( to a new DOM instance is similar to seri)HY(al)HY(iz)HY(ing)YH(
     to )SM(std::ostream)ES( or )SM(xercesc::XMLFor)HY(mat)HY(Tar)HY(get)YH()ES(,
     seri)HY(al)HY(iz)HY(ing)YH( to an exist)HY(ing)YH( DOM instance requires quite a bit of work
     from your side. You will need to set all the custom names)HY(pace)YH( mapping
     attributes as well as the )SM(schemaLo)HY(ca)HY(tion)YH()ES( and/or
     )SM(noNames)HY(paceSchemaLo)HY(ca)HY(tion)YH()ES( attributes. The follow)HY(ing)YH(
     listing should give you an idea about what needs to be done:
  )EP(

  ) 24 67 PR(// Obtain the object model.
//
std::auto_ptr<type> r = ...

using namespace xercesc;

XMLPlatformUtils::Initialize \201\202;

{
  // Create a DOM instance. Set custom namespace mapping and schema
  // location attributes.
  //
  DOMDocument& doc = ...

  // Serialize to DOM.
  //
  name \201doc, *r\202;

  // Serialize the DOM document to XML.
  //
  ...
}

XMLPlatformUtils::Terminate \201\202;)RP(

  )0 P(For more infor)HY(ma)HY(tion)YH( on how to create and seri)HY(al)HY(ize)YH( a DOM instance
     refer to the Xerces-C++ docu)HY(men)HY(ta)HY(tion)YH(. In addi)HY(tion)YH(, the
     )R7 2 A(C++/Tree Mapping
     FAQ)EA( shows how to imple)HY(ment)YH( these oper)HY(a)HY(tions)YH( using the XSD
     runtime util)HY(i)HY(ties)YH(.
  )EP(

  )0 1 88 H(5)WB 185 Sn()WB 92 Sn( Addi)HY(tional)YH( Func)HY(tion)HY(al)HY(ity)YH()EA()EH(

  )0 P(The C++/Tree mapping provides a number of optional features
     that can be useful in certain situ)HY(a)HY(tions)YH(. They are described
     in the follow)HY(ing)YH( sections.)EP(

  )0 2 89 H(5.1)WB 186 Sn()WB 93 Sn( DOM Asso)HY(ci)HY(a)HY(tion)YH()EA()EH(

  )0 P(Normally, after parsing is complete, the DOM docu)HY(ment)YH( which
     was used to extract the data is discarded. However, the parsing
     func)HY(tions)YH( can be instructed to preserve the DOM docu)HY(ment)YH(
     and create an asso)HY(ci)HY(a)HY(tion)YH( between the DOM nodes and object model
     nodes. When there is an asso)HY(ci)HY(a)HY(tion)YH( between the DOM and
     object model nodes, you can obtain the corre)HY(spond)HY(ing)YH( DOM element
     or attribute node from an object model node as well as perform
     the reverse tran)HY(si)HY(tion)YH(: obtain the corre)HY(spond)HY(ing)YH( object model
     from a DOM element or attribute node.)EP(

  )0 P(Main)HY(tain)HY(ing)YH( DOM asso)HY(ci)HY(a)HY(tion)YH( is normally useful when the appli)HY(ca)HY(tion)YH(
     needs access to XML constructs that are not preserved in the
     object model, for example, XML comments.
     Another useful aspect of DOM asso)HY(ci)HY(a)HY(tion)YH( is the ability of the
     appli)HY(ca)HY(tion)YH( to navi)HY(gate)YH( the docu)HY(ment)YH( tree using the generic DOM
     inter)HY(face)YH( \201for example, with the help of an XPath proces)HY(sor)YH(\202
     and then move back to the stat)HY(i)HY(cally)YH(-typed object model. Note
     also that while you can change the under)HY(ly)HY(ing)YH( DOM docu)HY(ment)YH(,
     these changes are not reflected in the object model and will
     be ignored during seri)HY(al)HY(iza)HY(tion)YH(. If you need to not only access
     but also modify some aspects of XML that are not preserved in
     the object model, then type customiza)HY(tion)YH( with custom parsing
     construc)HY(tors)YH( and seri)HY(al)HY(iza)HY(tion)YH( oper)HY(a)HY(tors)YH( should be used instead.)EP(

  )0 P(To request DOM asso)HY(ci)HY(a)HY(tion)YH( you will need to pass the
     )SM(xml_schema::flags::keep_dom)ES( flag to one of the
     parsing func)HY(tions)YH( \201see )0 66 1 A(Section 3.2,
     "Flags and Prop)HY(er)HY(ties)YH(")66 0 TN TL()Ec /AF f D( for more infor)HY(ma)HY(tion)YH(\202. In this case the
     DOM docu)HY(ment)YH( is retained and will be released when the object model
     is deleted. Note that since DOM nodes "out-live" the parsing func)HY(tion)YH(
     call, you need to initial)HY(ize)YH( the Xerces-C++ runtime before calling
     one of the parsing func)HY(tions)YH( with the )SM(keep_dom)ES( flag and
     termi)HY(nate)YH( it after the object model is destroyed \201see
     )0 65 1 A(Section 3.1, "Initial)HY(iz)HY(ing)YH( the Xerces-C++ Runtime")65 0 TN TL()Ec /AF f D(\202.)EP(

   )0 P(If the )SM(keep_dom)ES( flag is passed
      as the second argu)HY(ment)YH( to the copy construc)HY(tor)YH( and the copy
      being made is of a complete tree, then the DOM asso)HY(ci)HY(a)HY(tion)YH(
      is also main)HY(tained)YH( in the copy by cloning the under)HY(ly)HY(ing)YH(
      DOM docu)HY(ment)YH( and reestab)HY(lish)HY(ing)YH( the asso)HY(ci)HY(a)HY(tions)YH(. For example:)EP(

  ) 22 48 PR(using namespace xercesc;

XMLPlatformUtils::Initialize \201\202;

{
  // Parse XML to object model.
  //
  std::auto_ptr<type> r \201root \201
    "root.xml",
     xml_schema::flags::keep_dom |
     xml_schema::flags::dont_initialize\202\202;

   // Copy without DOM association.
   //
   type copy1 \201*r\202;

   // Copy with DOM association.
   //
   type copy2 \201*r, xml_schema::flags::keep_dom\202;
}

XMLPlatformUtils::Terminate \201\202;)RP(


  )0 P(To obtain the corre)HY(spond)HY(ing)YH( DOM node from an object model node
     you will need to call the )SM(_node)ES( acces)HY(sor)YH( func)HY(tion)YH(
     which returns a pointer to )SM(DOMNode)ES(. You can then query
     this DOM node's type and cast it to either )SM(DOMAttr*)ES(
     or )SM(DOMEle)HY(ment)YH(*)ES(. To obtain the corre)HY(spond)HY(ing)YH( object
     model node from a DOM node, the DOM user data API is used. The
     )SM(xml_schema::dom::tree_node_key)ES( vari)HY(able)YH( contains
     the key for object model nodes. The follow)HY(ing)YH( schema and code
     frag)HY(ment)YH( show how to navi)HY(gate)YH( from DOM to object model nodes
     and in the oppo)HY(site)YH( direc)HY(tion)YH(:)EP(

  ) 7 37 PR(<complexType name="object">
  <sequence>
    <element name="a" type="string"/>
  </sequence>
</complexType>

<element name="root" type="object"/>)RP(

  ) 42 68 PR(using namespace xercesc;

XMLPlatformUtils::Initialize \201\202;

{
  // Parse XML to object model.
  //
  std::auto_ptr<type> r \201root \201
    "root.xml",
     xml_schema::flags::keep_dom |
     xml_schema::flags::dont_initialize\202\202;

  DOMNode* n = root->_node \201\202;
  assert \201n->getNodeType \201\202 == DOMNode::ELEMENT_NODE\202;
  DOMElement* re = static_cast<DOMElement*> \201n\202;

  // Get the 'a' element. Note that it is not necessarily the
  // first child node of 'root' since there could be whitespace
  // nodes before it.
  //
  DOMElement* ae;

  for \201n = re->getFirstChild \201\202; n != 0; n = n->getNextSibling \201\202\202
  {
    if \201n->getNodeType \201\202 == DOMNode::ELEMENT_NODE\202
    {
      ae = static_cast<DOMElement*> \201n\202;
      break;
    }
  }
)WR(
  // Get from the 'a' DOM element to xml_schema::string object model
  // node.
  //
  xml_schema::type& t \201
    *reinterpret_cast<xml_schema::type*> \201
       ae->getUserData \201xml_schema::dom::tree_node_key\202\202\202;

  xml_schema::string& a \201dynamic_cast<xml_schema::string&> \201t\202\202;
}

XMLPlatformUtils::Terminate \201\202;)RP(

  )0 P(The 'mixed' example which can be found in the XSD distri)HY(bu)HY(tion)YH(
     shows how to handle the mixed content using DOM asso)HY(ci)HY(a)HY(tion)YH(.)EP(

  )0 2 90 H(5.2)WB 187 Sn()WB 94 Sn( Binary Seri)HY(al)HY(iza)HY(tion)YH()EA()EH(

  )0 P(Besides reading from and writing to XML, the C++/Tree mapping
     also allows you to save the object model to and load it from a
     number of prede)HY(fined)YH( as well as custom data repre)HY(sen)HY(ta)HY(tion)YH(
     formats. The prede)HY(fined)YH( binary formats are CDR \201Common Data
     Repre)HY(sen)HY(ta)HY(tion)YH(\202 and XDR \201eXter)HY(nal)YH( Data Repre)HY(sen)HY(ta)HY(tion)YH(\202. A
     custom format can easily be supported by provid)HY(ing)YH(
     inser)HY(tion)YH( and extrac)HY(tion)YH( oper)HY(a)HY(tors)YH( for basic types.)EP(

  )0 P(Binary seri)HY(al)HY(iza)HY(tion)YH( saves only the data without any meta
     infor)HY(ma)HY(tion)YH( or markup. As a result, saving to and loading
     from a binary repre)HY(sen)HY(ta)HY(tion)YH( can be an order of magni)HY(tude)YH(
     faster than parsing and seri)HY(al)HY(iz)HY(ing)YH( the same data in XML.
     Further)HY(more)YH(, the result)HY(ing)YH( repre)HY(sen)HY(ta)HY(tion)YH( is normally several
     times smaller than the equiv)HY(a)HY(lent)YH( XML repre)HY(sen)HY(ta)HY(tion)YH(. These
     prop)HY(er)HY(ties)YH( make binary seri)HY(al)HY(iza)HY(tion)YH( ideal for inter)HY(nal)YH( data
     exchange and storage. A typical appli)HY(ca)HY(tion)YH( that uses this
     facil)HY(ity)YH( stores the data and commu)HY(ni)HY(cates)YH( within the
     system using a binary format and reads/writes the data
     in XML when commu)HY(ni)HY(cat)HY(ing)YH( with the outside world.)EP(

  )0 P(In order to request the gener)HY(a)HY(tion)YH( of inser)HY(tion)YH( oper)HY(a)HY(tors)YH( and
     extrac)HY(tion)YH( construc)HY(tors)YH( for a specific prede)HY(fined)YH( or custom
     data repre)HY(sen)HY(ta)HY(tion)YH( stream, you will need to use the
     )SM(--gener)HY(ate)YH(-inser)HY(tion)YH()ES( and )SM(--gener)HY(ate)YH(-extrac)HY(tion)YH()ES(
     compiler options. See the
     )R8 2 A(XSD
     Compiler Command Line Manual)EA( for more infor)HY(ma)HY(tion)YH(.)EP(

  )0 P(Once the inser)HY(tion)YH( oper)HY(a)HY(tors)YH( and extrac)HY(tion)YH( construc)HY(tors)YH( are
     gener)HY(ated)YH(, you can use the )SM(xml_schema::istream)ES(
     and )SM(xml_schema::ostream)ES( wrapper stream templates
     to save the object model to and load it from a specific format.
     The follow)HY(ing)YH( code frag)HY(ment)YH( shows how to do this using ACE
     \201Adap)HY(tive)YH( Commu)HY(ni)HY(ca)HY(tion)YH( Envi)HY(ron)HY(ment)YH(\202 CDR streams as an example:)EP(

  ) 8 37 PR(<complexType name="object">
  <sequence>
    <element name="a" type="string"/>
    <element name="b" type="int"/>
  </sequence>
</complexType>

<element name="root" type="object"/>)RP(

  ) 21 51 PR(// Parse XML to object model.
//
std::auto_ptr<type> r \201root \201"root.xml"\202\202;

// Save to a CDR stream.
//
ACE_OutputCDR ace_ocdr;
xml_schema::ostream<ACE_OutputCDR> ocdr \201ace_ocdr\202;

ocdr << *r;

// Load from a CDR stream.
//
ACE_InputCDR ace_icdr \201buf, size\202;
xml_schema::istream<ACE_InputCDR> icdr \201ace_icdr\202;

std::auto_ptr<object> copy \201new object \201icdr\202\202;

// Serialize to XML.
//
root \201std::cout, *copy\202;)RP(

  )0 P(The XSD distri)HY(bu)HY(tion)YH( contains a number of exam)HY(ples)YH( that
     show how to save the object model to and load it from
     CDR, XDR, and a custom format.)EP(

  


  )0 1 91 H(Appendix)WB 188 Sn()WB 95 Sn( A \236 Default and Fixed Values)EA()EH(

  )0 P(The follow)HY(ing)YH( table summa)HY(rizes)YH( the effect of default and fixed
     values \201spec)HY(i)HY(fied)YH( with the )SM(default)ES( and )SM(fixed)ES(
     attributes, respec)HY(tively)YH(\202 on attribute and element values. The
     )SM(default)ES( and )SM(fixed)ES( attributes are mutu)HY(ally)YH(
     exclu)HY(sive)YH(. It is also worth)HY(while)YH( to note that the fixed value seman)HY(tics)YH(
     is a super)HY(set)YH( of the default value seman)HY(tics)YH(.
  )EP(

  
  )1 PT(

  )BR(
)BR(


)WB NL
/TE t D NP /OU t D TU PM 1 eq and{/Pn () D showpage}if end restore
